<p class="" data-start="173" data-end="419">The <strong data-start="177" data-end="197">Spring Framework</strong> is the backbone of modern Java development. From building robust web applications to creating scalable microservices, Spring empowers developers with tools that promote clean architecture, testability, and modular design.</p>
<p class="" data-start="421" data-end="737">In this complete guide, we’ll walk through everything you need to know about <strong data-start="498" data-end="526">Spring Framework in Java</strong> — starting from core concepts like <strong data-start="562" data-end="592">Inversion of Control (IoC)</strong> and <strong data-start="597" data-end="621">Dependency Injection</strong>, all the way to advanced features like <strong data-start="661" data-end="675">Spring MVC</strong>, <strong data-start="677" data-end="696">Spring Security</strong>, <strong data-start="698" data-end="705">AOP</strong>, and <strong data-start="711" data-end="736">Spring Boot Actuators</strong>.</p>
<p class="" data-start="739" data-end="1035">Whether you’re a beginner looking to understand the fundamentals or an experienced developer seeking to refresh and level up your skills, this guide provides real-world examples, annotations, configurations, and best practices to help you build production-ready Java applications with confidence.</p>
<p class="" data-start="1037" data-end="1138">Let’s get started with mastering Spring — one of the most essential frameworks in the Java ecosystem.</p>
<p data-start="912" data-end="1107">[toc]</p>


<hr class="" data-start="733" data-end="736" />

<h2 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">Inversion of Control (IoC)</strong></h2>
<p class="" data-start="208" data-end="474"><strong data-start="208" data-end="238">Inversion of Control (IoC)</strong> is a core design principle where the responsibility for creating and managing objects is handed over to a framework. In Spring, this responsibility is handled by the <strong data-start="405" data-end="422">IoC container</strong>, usually accessed through the <code data-start="453" data-end="473">ApplicationContext</code>.</p>
<p class="" data-start="476" data-end="767">Rather than having classes instantiate their own dependencies, you define these dependencies (beans) through configuration—using annotations like <code data-start="622" data-end="634">@Component</code>, <code data-start="636" data-end="648">@Autowired</code>, or XML/Java-based config. At runtime, the Spring container creates the beans and injects their required dependencies.</p>
<p class="" data-start="769" data-end="1011">This approach promotes <strong data-start="792" data-end="810">loose coupling</strong>, as classes no longer need to know <em data-start="846" data-end="851">how</em> their dependencies are created or <em data-start="886" data-end="893">where</em> they come from. They simply rely on abstractions (such as interfaces), making the codebase more modular and flexible.</p>
<p class="" data-start="1013" data-end="1231">Additionally, because dependencies are injected, it's easy to <strong data-start="1075" data-end="1110">substitute mock implementations</strong> during testing—without modifying the actual business logic. This leads to better <strong data-start="1192" data-end="1207">testability</strong> and cleaner unit tests.</p>


<hr class="" data-start="733" data-end="736" />

<h2 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">Dependency Injection (DI)</strong></h2>
<p class="" data-start="182" data-end="454"><strong data-start="214" data-end="243">Dependency Injection (DI)</strong> is the <strong data-start="251" data-end="309">core mechanism that enables Inversion of Control (IoC)</strong> in the Spring Framework. Instead of classes creating their own dependencies, Spring takes care of supplying them—usually via the <strong data-start="439" data-end="463">Spring IoC container</strong>.</p>
<p data-start="182" data-end="454">In simple terms, DI allows objects to receive their required dependencies <strong data-start="578" data-end="605">from an external source</strong>, rather than constructing them internally. This promotes <strong data-start="663" data-end="689">separation of concerns</strong>, makes components <strong data-start="708" data-end="726">easier to test</strong>, and encourages <strong data-start="743" data-end="761">modular design</strong>.</p>
<p class="" data-start="456" data-end="606">Spring provides several ways to inject dependencies:</p>
<p class="" data-start="975" data-end="1092"><strong data-start="975" data-end="1000">Constructor Injection</strong>: Best suited for required dependencies. Promotes immutability and is ideal for testing.</p>
<p class="" data-start="1096" data-end="1210"><strong data-start="1096" data-end="1116">Setter Injection</strong>: Used for optional or configurable dependencies. Easier to override in certain scenarios.</p>
<p class="" data-start="1214" data-end="1352"><strong data-start="1214" data-end="1233">Field Injection</strong>: A concise approach that uses annotations directly on class fields—but not ideal for unit testing or immutability.</p>


<hr class="thin-border" />

<h3 data-start="738" data-end="767"><strong>Constructor vs Setter vs Field Injection</strong></h3>
<div class="overflow-x-auto contain-inline-size responsive-table">
    <table data-pm-slice="3 3 []">
        <tbody>
        <tr>
            <th>Injection Type</th>
            <th>Use Case</th>
            <th>Pros</th>
            <th>Cons</th>
        </tr>
        <tr>
            <td>Constructor</td>
            <td>Required dependencies</td>
            <td>Immutable, testable</td>
            <td>Verbose with many dependencies</td>
        </tr>
        <tr>
            <td>Setter</td>
            <td>Optional/configurable props</td>
            <td>Easy to override</td>
            <td>Allows partially constructed beans</td>
        </tr>
        <tr>
            <td>Field</td>
            <td>Convenience</td>
            <td>Less boilerplate</td>
            <td>Harder to test, less flexible</td>
        </tr>
        </tbody>
    </table>
</div>
<div>

    Dependency Injection is the <strong data-start="2066" data-end="2098">foundation of loose coupling</strong> in Spring. By letting Spring handle dependency wiring, your code becomes more maintainable, easier to test, and flexible to change and scale.

</div>

<hr class="" data-start="733" data-end="736" />

<h2 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">Essential Spring Annotations</strong></h2>
<div class="overflow-x-auto contain-inline-size responsive-table">
    <table class="min-w-full" data-start="338" data-end="1853">
        <thead data-start="338" data-end="444">
        <tr data-start="338" data-end="444">
            <th data-start="338" data-end="365">Annotation</th>
            <th data-start="365" data-end="444">Description</th>
        </tr>
        </thead>
        <tbody data-start="553" data-end="1853">
        <tr data-start="553" data-end="712">
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)]" data-start="553" data-end="580"><code data-start="555" data-end="567">@Component</code></td>
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)] min-w-[calc(var(--thread-content-max-width)/2)]" data-start="580" data-end="712">Generic stereotype to mark a class as a Spring-managed bean. Enables automatic detection and registration in the Spring context.</td>
        </tr>
        <tr data-start="713" data-end="835">
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)]" data-start="713" data-end="740"><code data-start="715" data-end="725">@Service</code></td>
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)] min-w-[calc(var(--thread-content-max-width)/2)]" data-start="740" data-end="835">Specialized <code data-start="754" data-end="766">@Component</code> for service-layer classes (business logic). Adds semantic clarity.</td>
        </tr>
        <tr data-start="836" data-end="952">
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)]" data-start="836" data-end="863"><code data-start="838" data-end="851">@Repository</code></td>
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)] min-w-[calc(var(--thread-content-max-width)/2)]" data-start="863" data-end="952">Specialized <code data-start="877" data-end="889">@Component</code> for data access layer (DAOs). Enables exception translation.</td>
        </tr>
        <tr data-start="953" data-end="1059">
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)]" data-start="953" data-end="980"><code data-start="955" data-end="968">@Controller</code></td>
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)] min-w-[calc(var(--thread-content-max-width)/3)]" data-start="980" data-end="1059">Declares a class as a Spring MVC controller for handling web requests.</td>
        </tr>
        <tr data-start="1060" data-end="1176">
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)]" data-start="1060" data-end="1087"><code data-start="1062" data-end="1079">@RestController</code></td>
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)] min-w-[calc(var(--thread-content-max-width)/2)]" data-start="1087" data-end="1176">Combines <code data-start="1098" data-end="1111">@Controller</code> and <code data-start="1116" data-end="1131">@ResponseBody</code> to simplify building RESTful web services.</td>
        </tr>
        <tr data-start="1177" data-end="1289">
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)]" data-start="1177" data-end="1204"><code data-start="1179" data-end="1191">@Autowired</code></td>
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)] min-w-[calc(var(--thread-content-max-width)/2)]" data-start="1204" data-end="1289">Automatically injects dependencies by type into constructors, setters, or fields.</td>
        </tr>
        <tr data-start="1290" data-end="1411">
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)]" data-start="1290" data-end="1317"><code data-start="1292" data-end="1304">@Qualifier</code></td>
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)] min-w-[calc(var(--thread-content-max-width)/2)]" data-start="1317" data-end="1411">Helps resolve ambiguity when multiple beans of the same type exist—used with <code data-start="1396" data-end="1408">@Autowired</code>.</td>
        </tr>
        <tr data-start="1412" data-end="1526">
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)]" data-start="1412" data-end="1439"><code data-start="1414" data-end="1424">@Primary</code></td>
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)] min-w-[calc(var(--thread-content-max-width)/2)]" data-start="1439" data-end="1526">Marks one bean as the default to use during autowiring when multiple options exist.</td>
        </tr>
        <tr data-start="1527" data-end="1636">
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)]" data-start="1527" data-end="1554"><code data-start="1529" data-end="1553">@ConditionalOnProperty</code></td>
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)] min-w-[calc(var(--thread-content-max-width)/3)]" data-start="1554" data-end="1636">Registers a bean only if a specific property exists in the configuration file.</td>
        </tr>
        <tr data-start="1637" data-end="1733">
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)]" data-start="1637" data-end="1664"><code data-start="1639" data-end="1653">@Conditional</code></td>
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)] min-w-[calc(var(--thread-content-max-width)/3)]" data-start="1664" data-end="1733">Registers a bean based on custom logic or environment conditions.</td>
        </tr>
        <tr data-start="1734" data-end="1853">
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)]" data-start="1734" data-end="1761"><code data-start="1736" data-end="1747">@Profile</code></td>
            <td class="max-w-[calc(var(--thread-content-max-width)*2/3)] min-w-[calc(var(--thread-content-max-width)/2)]" data-start="1761" data-end="1853">Activates beans only for specific profiles.</td>
        </tr>
        </tbody>
    </table>
</div>

<hr class="" data-start="733" data-end="736" />

<h2 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">IoC Container &amp; Bean Lifecycle</strong></h2>
<p data-start="195" data-end="451"><strong data-start="195" data-end="244">Spring’s IoC (Inversion of Control) container</strong> is responsible for managing the lifecycle, dependencies, and configuration of application objects known as <strong data-start="352" data-end="361">beans</strong>. It creates and injects these beans based on metadata defined through annotations or XML.</p>
<p data-start="453" data-end="504">Spring provides two main container implementations:</p>

<ul>
    <li data-start="507" data-end="593"><strong data-start="507" data-end="531"><code data-start="509" data-end="529">ApplicationContext</code></strong> – commonly used and feature-rich (supports AOP, events, etc.)</li>
    <li data-start="596" data-end="670"><strong data-start="596" data-end="613"><code data-start="598" data-end="611">BeanFactory</code></strong> – the basic, lightweight container (now mostly internal)</li>
</ul>
<h4>Bean lifecycle phases</h4>
<ul>
    <li data-start="706" data-end="757"><strong data-start="706" data-end="723">Instantiation</strong> – The container creates the bean.</li>
    <li data-start="761" data-end="848"><strong data-start="761" data-end="785">Dependency Injection</strong> – Dependencies are injected via constructor, setter, or field.</li>
    <li data-start="976" data-end="1083"><strong data-start="976" data-end="994">Initialization</strong> – Custom logic via <code data-start="1014" data-end="1030">@PostConstruct</code> or <code data-start="1034" data-end="1056">afterPropertiesSet()</code> (from <code data-start="1063" data-end="1081">InitializingBean</code>).</li>
    <li data-start="1087" data-end="1146"><strong data-start="1087" data-end="1109">Bean Ready for Use</strong> – The bean is now fully initialized.</li>
    <li data-start="1150" data-end="1264"><strong data-start="1150" data-end="1165">Destruction</strong> – Cleanup via <code data-start="1180" data-end="1193">@PreDestroy</code> or <code data-start="1197" data-end="1208">destroy()</code> (from <code data-start="1215" data-end="1231">DisposableBean</code>), triggered on context shutdown.</li>
</ul>
<p data-start="1266" data-end="1391">💡 You can <strong data-start="1277" data-end="1305">hook into this lifecycle</strong> using annotations or lifecycle interfaces to execute custom logic at specific stages.</p>


<hr class="" data-start="733" data-end="736" />

<h2 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">Getting Started with Spring Boot</strong></h2>
Spring Boot makes it incredibly easy to bootstrap a new Spring application. Here's how to create a new Spring Boot project using <strong>Spring Initializr</strong>:
<h4>Steps to Create a Spring Boot App</h4>
<ul>
    <li>Go to <strong><a href="https://start.spring.io">https://start.spring.io</a></strong></li>
    <li>Choose the following settings:
        <ul>
            <li><strong>Project</strong>: Maven or Gradle</li>
            <li><strong>Language</strong>: Java</li>
            <li><strong>Spring Boot version</strong>: Latest stable (e.g., 3.4.5)</li>
            <li><strong>Group</strong>: <code>com.example</code></li>
            <li><strong>Artifact</strong>: <code>myapp</code></li>
            <li><strong>Name</strong>: <code>MyApp</code></li>
            <li><strong>Packaging</strong>: Jar</li>
            <li><strong>Java</strong>: Latest version (e.g., 21)</li>
            <li><strong>Dependencies</strong>: Add <code>Spring Web</code> for now. (Others as needed) <code>Spring Data JPA</code>, <code>Spring Security</code>.</li>
        </ul>
    </li>
    <li>Click <strong>Generate</strong> to download a <code>.zip</code> file.</li>
</ul>
Unzip and Run the application directly from command line (Dev Mode):
<pre><code class="language-bash line-numbers"> # For Maven projects
./mvnw spring-boot:run</code></pre>
<pre><code class="language-bash line-numbers"># For Gradle projects
./gradlew bootRun</code></pre>
Also, open the project in your favorite IDE (e.g., IntelliJ IDEA or Eclipse)<strong> </strong>and Run the main class (<code>@SpringBootApplication</code>).

Additionally, you can build and run as executable jar (Production Mode):
<pre><code class="language-bash line-numbers"># Maven
mvn clean package
java -jar target/myapp-0.0.1-SNAPSHOT.jar</code></pre>
<pre><code class="language-bash line-numbers"># Gradle
./gradlew build
java -jar build/libs/myapp-0.0.1-SNAPSHOT.jar</code></pre>
You can verify the following logs to confirm the application started successfully:
<pre><code class="language-bash line-numbers">[INFO] [TomcatWebServer] Tomcat started on port 8080 (http) with context path '/'
[INFO] [MyAppApplication] Started MyAppApplication in 0.792 seconds (process running for 0.975)</code></pre>
Your Spring Boot application is now up and running! You can visit <code>http://localhost:8080</code> to verify.

You will get a <b>Whitelabel Error Page</b> as there are no request mappings yet. Press <code>Ctrl+C</code> to stop the server.

<hr class="thin-border" />

<h3 data-start="738" data-end="767"><strong data-start="742" data-end="765">Spring Boot Configuration</strong></h3>
Spring Boot simplifies configuration via <code style="font-size: inherit;">application.properties</code> or <code style="font-size: inherit;">application.yaml</code>.

Add the following properties to the configuration file, then restart the application.
<pre><code class="language-bash line-numbers"># application.properties
# Changes default port from 8080 to 8081
server.port=8081
# Sets the base context path
server.servlet.context-path=/myapp</code></pre>
<pre><code class="language-yaml line-numbers"># application.yaml
server:
  port: 8081     # Changes default port from 8080 to 8081
  servlet:
      context-path: /myapp  # Sets the base context path</code></pre>
You should see the updated logs as below:
<pre><code class="language-bash line-numbers">[INFO] [TomcatWebServer] Tomcat started on port 8081 (http) with context path '/myapp'
[INFO] [MyAppApplication] Started MyAppApplication in 0.747 seconds (process running for 0.927)</code></pre>
You can visit <code>http://localhost:8081/myapp</code> to verify the application is up and running!

Use <code>@SpringBootConfiguration</code> (meta-annotated on <code>@SpringBootApplication</code>) for bootstrapping custom config classes.

<hr class="" data-start="733" data-end="736" />

<h2 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">Spring Web MVC</strong></h2>
<p data-start="164" data-end="333"><strong data-start="164" data-end="182">Spring Web MVC</strong> is a powerful framework in the Spring ecosystem for building <strong data-start="244" data-end="257">REST APIs</strong> and <strong data-start="262" data-end="282">web applications</strong> using the <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller"><strong data-start="293" data-end="324">Model-View-Controller (MVC)</strong></a> pattern.</p>
<p data-start="335" data-end="386">It provides a clean separation of concerns between:</p>

<ul>
    <li data-start="390" data-end="427"><strong data-start="390" data-end="404">Controller</strong>: Handles HTTP requests</li>
    <li data-start="430" data-end="481"><strong data-start="430" data-end="439">Model</strong>: Contains application data/business logic</li>
    <li data-start="484" data-end="529"><strong data-start="484" data-end="492">View</strong>: Renders the response (HTML or JSON)</li>
</ul>
<p data-start="531" data-end="641">The <strong data-start="535" data-end="558"><code data-start="537" data-end="556">DispatcherServlet</code></strong> acts as the front controller that routes incoming requests to the correct handler.</p>

<h4 data-start="531" data-end="641">Core Annotations</h4>
<div class="overflow-x-auto contain-inline-size responsive-table">
    <table>
        <thead>
        <tr>
            <th>Annotation</th>
            <th>Purpose</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td><code>@RestController</code></td>
            <td>Marks a class as a REST API controller</td>
        </tr>
        <tr>
            <td><code>@GetMapping</code></td>
            <td>Maps GET requests (e.g., read data)</td>
        </tr>
        <tr>
            <td><code>@PostMapping</code></td>
            <td>Maps POST requests (e.g., create data)</td>
        </tr>
        <tr>
            <td><code>@RequestBody</code></td>
            <td>Binds JSON request payload to a Java object</td>
        </tr>
        <tr>
            <td><code>@RequestParam</code></td>
            <td>Binds a query parameter from the URL</td>
        </tr>
        <tr>
            <td><code>@PathVariable</code></td>
            <td>Binds a dynamic path segment (e.g., <code>/users/{id}</code>)</td>
        </tr>
        </tbody>
    </table>
</div>
<h4>Example</h4>
<div>

    <code data-start="264" data-end="273">UserDTO</code> (data transfer object)
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">public class UserDTO {

    private String username;
    private String email;
    private String password;

    // Getters and Setters
    public String getUsername() {
        return username;
    }

    public String getEmail() {
        return email;
    }

    public String getPassword() {
        return password;
    }
}</code></pre>
    </div>
    <code data-start="580" data-end="598">UserService</code> (business logic)
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@Service
public class UserService {

    private static final Logger logger = LoggerFactory.getLogger(UserService.class);

    // Dummy in-memory storage
    private final Map&lt;String, UserDTO&gt; userStore = new HashMap&lt;&gt;();

    public String registerUser(UserDTO userDTO) {
        userStore.put(userDTO.getUsername(), userDTO);
        logger.info("User registered: {}", userDTO.getUsername());
        return "User '" + userDTO.getUsername() + "' registered successfully!";
    }

    public UserDTO findByUsername(String username) {
        logger.info("Finding by username: {}", username);
        return userStore.get(username);
    }
}</code></pre>
    </div>
    <code data-start="1510" data-end="1531">UserController</code> (uses <code data-start="1538" data-end="1551">UserService</code>)
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired  // Field injection
    private UserService userService;

    /*
    @Autowired  // constructor injection (recommended)
    public UserController(UserService userService) {
      this.userService = userService;
    }
    */

    /**
     * Register a new user via POST
     * Example: POST /api/users/register
     */
    @PostMapping("/register")
    public String registerUser(@RequestBody UserDTO userDTO) {
        return userService.registerUser(userDTO);
    }

    /**
     * Get user by query param
     * Example: GET /api/users/find?username=srimanta
     */
    @GetMapping("/find")
    public UserDTO getUserByQueryParam(@RequestParam String username) {
        return userService.findByUsername(username);
    }

    /**
     * Get user by path variable
     * Example: GET /api/users/srimanta
     */
    @GetMapping("/{username}")
    public UserDTO getUserByPath(@PathVariable String username) {
        return userService.findByUsername(username);
    }
}</code></pre>
    </div>
    <h5>Sample cURL Test</h5>
    <pre><code class="language-bash line-numbers">$ curl -X POST http://localhost:8081/myapp/api/users/register \
-H "Content-Type: application/json" \
-d '{
"username": "srimanta",
"email": "srimanta@xmail.com",
"password": "srimanta@123"
}'
User 'srimanta' registered successfully!
$
$ curl -X GET "http://localhost:8081/myapp/api/users/find?username=srimanta"
{"username":"srimanta","email":"srimanta@xmail.com","password":"srimanta@123"}
$
$ curl http://localhost:8081/myapp/api/users/srimanta
{"username":"srimanta","email":"srimanta@xmail.com","password":"srimanta@123"}</code></pre>
    <h5>Sample console logs</h5>
    <pre><code class="language-bash line-numbers">[INFO] [UserService] User registered: srimanta
[INFO] [UserService] Finding by username: srimanta
[INFO] [UserService] Finding by username: srimanta</code></pre>
</div>

<hr class="" data-start="733" data-end="736" />

<h2 data-start="738" data-end="767"><strong>Spring Validations</strong></h2>
<p data-start="169" data-end="336"><strong data-start="169" data-end="190">Spring Validation</strong> is used to <strong data-start="202" data-end="255">automatically validate user input or request data</strong> in Spring applications — particularly in <strong data-start="297" data-end="310">REST APIs</strong> and <strong data-start="315" data-end="335">form submissions</strong>.</p>
<p data-start="338" data-end="507">It integrates with <strong data-start="357" data-end="392">JSR-303/JSR-380 Bean Validation</strong> <strong>(<a href="https://beanvalidation.org/">Jakarta Bean Validation</a>)</strong> and allows you to apply validation rules directly on <strong data-start="472" data-end="488">model fields</strong> using annotations.</p>

<h4 data-start="324" data-end="385">Common Validation Annotations</h4>
<div class="_tableContainer_16hzy_1">
    <div class="_tableWrapper_16hzy_14 group flex w-fit flex-col-reverse" tabindex="-1">
        <table class="w-fit min-w-(--thread-content-width)" data-start="387" data-end="799">
            <thead data-start="387" data-end="445">
            <tr data-start="387" data-end="445">
                <th data-start="387" data-end="406" data-col-size="sm">Annotation</th>
                <th data-start="406" data-end="445" data-col-size="sm">Purpose</th>
            </tr>
            </thead>
            <tbody data-start="505" data-end="799">
            <tr data-start="505" data-end="563">
                <td data-start="505" data-end="524" data-col-size="sm"><code data-start="507" data-end="517">@NotNull</code></td>
                <td data-start="524" data-end="563" data-col-size="sm">Field must not be <code data-start="544" data-end="550">null</code></td>
            </tr>
            <tr data-start="564" data-end="622">
                <td data-start="564" data-end="583" data-col-size="sm"><code data-start="566" data-end="577">@NotBlank</code></td>
                <td data-col-size="sm" data-start="583" data-end="622">Must not be empty or whitespace</td>
            </tr>
            <tr data-start="623" data-end="681">
                <td data-start="623" data-end="642" data-col-size="sm"><code data-start="625" data-end="633">@Email</code></td>
                <td data-col-size="sm" data-start="642" data-end="681">Must be a valid email address</td>
            </tr>
            <tr data-start="682" data-end="740">
                <td data-start="682" data-end="701" data-col-size="sm"><code data-start="684" data-end="701">@Size(min, max)</code></td>
                <td data-start="701" data-end="740" data-col-size="sm">Enforces string or collection size</td>
            </tr>
            <tr data-start="741" data-end="799">
                <td data-start="741" data-end="760" data-col-size="sm"><code data-start="743" data-end="749">@Min</code>, <code data-start="751" data-end="757">@Max</code></td>
                <td data-col-size="sm" data-start="760" data-end="799">Set numeric limits</td>
            </tr>
            </tbody>
        </table>
    </div>
</div>
<h4>How It Works</h4>
Use <code data-start="996" data-end="1004">@Valid</code> or <code data-start="1008" data-end="1020">@Validated</code> to <strong data-start="1024" data-end="1046">trigger validation</strong>.
<ul>
    <li data-start="1052" data-end="1106"><code data-start="1052" data-end="1060">@Valid</code> → on method parameters (e.g., <code data-start="1091" data-end="1105">@RequestBody</code>)</li>
    <li data-start="1111" data-end="1182"><code data-start="1111" data-end="1123">@Validated</code> → on class level (supports groups and advanced validation)</li>
</ul>
If validation fails, Spring throws a <code data-start="1222" data-end="1255">MethodArgumentNotValidException</code>.
<h4>Example</h4>
Add dependencies to <code data-start="430" data-end="439">pom.xml</code> / <code data-start="430" data-end="439">build.gradle</code>:
<pre><code class="language-xml line-numbers">&lt;!-- Maven --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<pre><code class="language-groovy line-numbers">// Gradle
implementation 'org.springframework.boot:spring-boot-starter-validation'</code></pre>
<code>UserDTO</code> (with constraints)
<div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">public class UserDTO {

    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 20, message = "Username must be between 3 and 20 characters")
    private String username;

    @Email(message = "Invalid email format")
    private String email;

    @NotBlank(message = "Password is required")
    @Size(min = 6, message = "Password must be at least 6 characters")
    private String password;

    // Getters and Setters
    public String getUsername() {
        return username;
    }

    public String getEmail() {
        return email;
    }

    public String getPassword() {
        return password;
    }
}</code></pre>
</div>
<code>UserController</code> with <code data-start="1028" data-end="1040">@Validated</code> and <code data-start="1045" data-end="1053">@Valid</code>
<div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@RestController
@RequestMapping("/api/users")
@Validated // Enables method-level validation (useful for path variables, service params, etc.)
public class UserController {

    @Autowired  // Field injection
    private UserService userService;

    /**
     * Register a new user via POST
     * Example: POST /api/users/register
     */
    @PostMapping("/register")
    public String registerUser(@Valid @RequestBody UserDTO userDTO) {
        return userService.registerUser(userDTO);
    }

    /**
     * Get user by query param
     * Example: GET /api/users/find?username=srimanta
     */
    @GetMapping("/find")
    public UserDTO getUserByQueryParam(@RequestParam String username) {
        return userService.findByUsername(username);
    }

    /**
     * Get user by path variable
     * Example: GET /api/users/srimanta
     */
    @GetMapping("/{username}")
    public UserDTO getUserByPath(@PathVariable String username) {
        return userService.findByUsername(username);
    }
}</code></pre>
</div>
<code>GlobalExceptionHandler</code> (handle validation errors gracefully)
<div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@RestControllerAdvice
public class GlobalExceptionHandler {

    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Map&lt;String, String&gt; handleValidationErrors(MethodArgumentNotValidException ex) {
        Map&lt;String, String&gt; errors = new LinkedHashMap&lt;&gt;();
        ex.getBindingResult().getFieldErrors().forEach(error -&gt; errors.put(error.getField(), error.getDefaultMessage()));
        return errors;
    }
}</code></pre>
</div>
<h5>Sample cURL Test</h5>
<pre><code class="language-bash line-numbers">$ curl -X POST http://localhost:8081/myapp/api/users/register \
-H "Content-Type: application/json" \
-d '{
"username": "du",
"email": "dummy@.com",
"password": ""
}'
{"username":"Username must be between 3 and 20 characters","email":"Invalid email format","password":"Password must be at least 6 characters"}</code></pre>

<hr class="" data-start="733" data-end="736" />

<h2 data-start="738" data-end="767"><strong>WebMvcConfigurer &amp; Message Converters</strong></h2>
<p data-start="179" data-end="307"><strong data-start="179" data-end="206">Spring WebMvcConfigurer</strong> is an interface used to <strong data-start="231" data-end="264">customize <a href="https://oopscoder.com/spring-framework-in-java/#spring-web-mvc">Spring MVC</a> behavior</strong> without overriding the full configuration.</p>
<p data-start="309" data-end="331">It's ideal for adding:</p>

<ul>
    <li data-start="335" data-end="366">Custom <strong data-start="344" data-end="366">message converters</strong></li>
    <li data-start="369" data-end="392">HTTP <strong data-start="376" data-end="392">interceptors</strong></li>
    <li data-start="395" data-end="421">Global <strong data-start="404" data-end="421"><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a> settings</strong></li>
    <li data-start="424" data-end="466">Formatters, argument resolvers, and more</li>
</ul>
<p data-start="743" data-end="856"><strong data-start="743" data-end="765">Message converters</strong> in Spring handle the conversion between <strong data-start="806" data-end="855">Java objects and HTTP request/response bodies</strong>.</p>
<p data-start="858" data-end="920">They’re used internally by <code data-start="885" data-end="899">@RequestBody</code> and <code data-start="904" data-end="919">@ResponseBody</code>.</p>

<h4>Example</h4>
Here’s an example of a <strong data-start="104" data-end="123">REST controller</strong> that generates both <strong data-start="144" data-end="170">JSON and XML responses</strong> using <strong data-start="177" data-end="200">content negotiation</strong> with <code data-start="206" data-end="228">HttpMessageConverter</code>s.

Add dependencies to <code data-start="430" data-end="439">pom.xml</code> / <code data-start="430" data-end="439">build.gradle</code>:
<div>
    <div>
<pre><code class="language-xml line-numbers">&lt;!-- Maven --&gt;
&lt;!-- JSON (comes with Spring Boot Starter Web) --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- XML support --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
    </div>
</div>
<pre><code class="language-groovy line-numbers">// Gradle
implementation 'com.fasterxml.jackson.core:jackson-databind'
implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml'</code></pre>
<div>

    <code>UserDTO</code> (with Jackson annotations for better XML)
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@JacksonXmlRootElement(localName = "user")
public class UserDTO {

    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 20, message = "Username must be between 3 and 20 characters")
    @JsonProperty("username")
    private String username;

    @Email(message = "Invalid email format")
    @JsonProperty("email")
    private String email;

    @NotBlank(message = "Password is required")
    @Size(min = 6, message = "Password must be at least 6 characters")
    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)  // excluded from response (serialization)
    private String password;

    // Constructors
    public UserDTO() {
    }

    public UserDTO(String username, String email, String password) {
        this.username = username;
        this.email = email;
        this.password = password;
    }

    // Getters and Setters
    public String getUsername() {
        return username;
    }

    public String getEmail() {
        return email;
    }

    public String getPassword() {
        return password;
    }
}</code></pre>
    </div>
    <code>WebMvcConfigurer</code> Implementation
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Override
    public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
        // JSON converter
        converters.add(new MappingJackson2HttpMessageConverter(new ObjectMapper()));

        // XML converter
        converters.add(new MappingJackson2XmlHttpMessageConverter(new XmlMapper()));
    }
}
</code></pre>
    </div>
    <code>UserController</code>
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@RestController
@RequestMapping("/api/users")
@Validated // Enables method-level validation (useful for path variables, service params, etc.)
public class UserController {

    @Autowired  // Field injection
    private UserService userService;

    /**
     * Register a new user via POST
     * Example: POST /api/users/register
     */
    @PostMapping("/register")
    public String registerUser(@Valid @RequestBody UserDTO userDTO) {
        return userService.registerUser(userDTO);
    }

    /**
     * Get user by query param
     * Example: GET /api/users/find?username=srimanta
     */
    @GetMapping("/find")
    public UserDTO getUserByQueryParam(@RequestParam String username) {
        return userService.findByUsername(username);
    }

    /**
     * Get user by path variable
     * Example: GET /api/users/srimanta
     */
    @GetMapping(value = "/{username}", produces = {"application/json", "application/xml"})
    public UserDTO getUserByPath(@PathVariable String username) {
        return userService.findByUsername(username);
    }
}</code></pre>
    </div>
    <h5>Sample cURL Test</h5>
    <pre><code class="language-bash line-numbers">$ curl -X POST http://localhost:8081/myapp/api/users/register \
-H "Content-Type: application/json" \
-d '{
"username": "srimanta",
"email": "srimanta@xmail.com",
"password": "srimanta@123"
}'
User 'srimanta' registered successfully!
$
$ curl http://localhost:8081/myapp/api/users/srimanta
{"username":"srimanta","email":"srimanta@xmail.com"}
$
$ curl http://localhost:8081/myapp/api/users/srimanta \
-H "Accept: application/xml"
&lt;user&gt;&lt;username&gt;srimanta&lt;/username&gt;&lt;email&gt;srimanta@xmail.com&lt;/email&gt;&lt;/user&gt;</code></pre>
</div>

<hr class="" data-start="733" data-end="736" />

<h2 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">Spring JDBC Template</strong></h2>
<p data-start="166" data-end="348"><strong data-start="166" data-end="190">Spring JDBC Template</strong> is a utility class in the Spring Framework that simplifies <strong data-start="250" data-end="273">database operations</strong> like querying, inserting, updating, and deleting data using <strong data-start="334" data-end="347">plain SQL</strong>.</p>
<p data-start="350" data-end="408">It significantly reduces <strong data-start="375" data-end="395">boilerplate code</strong> by handling:</p>

<ul>
    <li data-start="412" data-end="433">Connection management</li>
    <li data-start="436" data-end="457">Statement preparation</li>
    <li data-start="460" data-end="479">ResultSet iteration</li>
    <li data-start="482" data-end="500">Exception handling</li>
</ul>
<h4>Key Features</h4>
<ul>
    <li data-start="528" data-end="556">Simplifies common JDBC tasks</li>
    <li data-start="559" data-end="598">Executes SQL queries and updates easily</li>
    <li data-start="601" data-end="648">Integrates with Spring's transaction management</li>
    <li data-start="651" data-end="713">Uses <code data-start="656" data-end="667">RowMapper</code> to convert <code data-start="679" data-end="690">ResultSet</code> rows into Java objects</li>
</ul>
<h4>Example</h4>
Add dependencies to <code data-start="430" data-end="439">pom.xml</code> / <code data-start="430" data-end="439">build.gradle</code>:
<div>
    <div>
<pre><code class="language-xml line-numbers">&lt;!-- Maven --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;!-- Use H2 for testing --&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
    </div>
</div>
<pre><code class="language-groovy line-numbers">// Gradle
implementation 'org.springframework.boot:spring-boot-starter-jdbc'
runtimeOnly 'com.h2database:h2'</code></pre>
Add the following properties to the configuration file:
<div>
<pre><code class="language-bash line-numbers"># application.properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.h2.console.enabled=true
spring.jpa.hibernate.ddl-auto=none</code></pre>
    <pre><code class="language-yaml line-numbers"># application.yaml
spring:
  datasource:
      url: jdbc:h2:mem:testdb
      driver-class-name: org.h2.Driver
      username: sa
      password: ""  # Empty password

  h2:
      console:
          enabled: true

  jpa:
      hibernate:
          ddl-auto: none  # Disable auto schema generation</code></pre>
    SQL Schema (schema.sql)
    <pre><code class="language-sql line-numbers">CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(20) NOT NULL,
    email VARCHAR(100),
    password VARCHAR(60) NOT NULL
);
</code></pre>
    Spring Boot will automatically pick this file from <code data-start="943" data-end="963">src/main/resources</code>.

    <code>User</code> Model
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">public class User {
    private Long id;
    private String username;
    private String email;
    private String password;

    // Constructors
    public User() {
    }

    public User(String username, String email, String password) {
        this.username = username;
        this.email = email;
        this.password = password;
    }

    // Getters &amp; Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}</code></pre>
    </div>
    <code>UserRepository</code> using <code data-start="1354" data-end="1368">JdbcTemplate</code> and <code>NamedParameterJdbcTemplate</code> (named parameters to prevent SQL injection with <code data-start="208" data-end="211">?</code> placeholders)
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@Repository
public class UserRepository {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

    public int registerUser(User user) {
        String sql = "INSERT INTO users (username, email, password) VALUES (?, ?, ?)";
        return jdbcTemplate.update(sql, user.getUsername(), user.getEmail(), user.getPassword());
    }

    public Optional findUserByUsername(String username) {
        String sql = "SELECT * FROM users WHERE username = :username";
        MapSqlParameterSource params = new MapSqlParameterSource()
                .addValue("username", username);

        List users = namedParameterJdbcTemplate.query(sql, params, new BeanPropertyRowMapper&lt;&gt;(User.class));
        return users.stream().findFirst();
    }
}</code></pre>
    </div>
    <code>UserService</code>
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@Service
public class UserService {

    private static final Logger logger = LoggerFactory.getLogger(UserService.class);

    @Autowired
    private UserRepository userRepository;

    public String registerUser(UserDTO userDTO) {
        if (findByUsername(userDTO.getUsername()) != null)
            throw new RuntimeException("User already exists");

        User user = new User(userDTO.getUsername(), userDTO.getEmail(), userDTO.getPassword());

        int update = userRepository.registerUser(user);
        String status = update == 1 ? "successful" : "failed";
        logger.info("User '{}' registration {}!", userDTO.getUsername(), status);
        return "User '" + userDTO.getUsername() + "' registration " + status;
    }

    public User findByUsername(String username) {
        logger.info("Finding by username: {}", username);
        Optional user = userRepository.findUserByUsername(username);
        return user.orElse(null);
    }
}</code></pre>
    </div>
    <code>UserController</code>
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@RestController
@RequestMapping("/api/users")
@Validated // Enables method-level validation (useful for path variables, service params, etc.)
public class UserController {

    @Autowired  // Field injection
    private UserService userService;

    /**
     * Register a new user via POST
     * Example: POST /api/users/register
     */
    @PostMapping("/register")
    public String registerUser(@Valid @RequestBody UserDTO userDTO) {
        return userService.registerUser(userDTO);
    }

    /**
     * Get user by query param
     * Example: GET /api/users/find?username=srimanta
     */
    @GetMapping("/find")
    public User getUserByQueryParam(@RequestParam String username) {
        return userService.findByUsername(username);
    }

    /**
     * Get user by path variable
     * Example: GET /api/users/srimanta
     */
    @GetMapping(value = "/{username}", produces = {"application/json", "application/xml"})
    public User getUserByPath(@PathVariable String username) {
        return userService.findByUsername(username);
    }
}</code></pre>
    </div>
    <h5>Sample cURL Test</h5>
    <pre><code class="language-bash line-numbers">$ curl -X POST http://localhost:8081/myapp/api/users/register \
-H "Content-Type: application/json" \
-d '{
"username": "srimanta",
"email": "srimanta@xmail.com",
"password": "srimanta@123"
}'
User 'srimanta' registration successful
$
$ curl -X GET "http://localhost:8081/myapp/api/users/find?username=srimanta"
{"id":1,"username":"srimanta","email":"srimanta@xmail.com","password":"srimanta@123"}</code></pre>
</div>

<hr class="" data-start="733" data-end="736" />

<h2 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">Spring Boot Actuators</strong></h2>
<strong data-start="161" data-end="185">Spring Boot Actuator</strong> provides <strong data-start="195" data-end="242">production-ready monitoring and diagnostics</strong> for your application with minimal configuration. It exposes a set of built-in endpoints that give insights into the system's internals — making it easier to monitor, manage, and debug applications in real-time.
<h4 data-start="455" data-end="480">Common Endpoints</h4>
<ul>
    <li data-start="483" data-end="584"><strong data-start="483" data-end="505"><code data-start="485" data-end="503">/actuator/health</code></strong> – Shows application health status (e.g., database, disk, service availability)</li>
    <li data-start="587" data-end="677"><strong data-start="587" data-end="610"><code data-start="589" data-end="608">/actuator/metrics</code></strong> – Exposes system and custom metrics like memory, CPU, thread usage</li>
    <li data-start="680" data-end="753"><strong data-start="680" data-end="700"><code data-start="682" data-end="698">/actuator/info</code></strong> – Displays metadata (e.g., app version, description)</li>
    <li data-start="756" data-end="823"><strong data-start="756" data-end="775"><code data-start="758" data-end="773">/actuator/env</code></strong> – Lists environment variables and config values</li>
    <li data-start="826" data-end="895"><strong data-start="826" data-end="849"><code data-start="828" data-end="847">/actuator/loggers</code></strong> – Allows runtime management of logging levels</li>
</ul>
<p data-start="897" data-end="1108">Actuator endpoints can be <strong data-start="923" data-end="959">enabled, secured, and customized</strong> via <code data-start="964" data-end="988">application.properties|yaml</code>.</p>
<p data-start="897" data-end="1108">They're also easily integrated with observability tools like <strong data-start="1053" data-end="1067">Prometheus</strong>, <strong data-start="1069" data-end="1080">Grafana</strong>, and <strong data-start="1086" data-end="1107">Spring Boot Admin</strong>.</p>

<h4>Example</h4>
Add dependencies to <code data-start="430" data-end="439">pom.xml</code> / <code data-start="430" data-end="439">build.gradle</code>:
<div>
<pre><code class="language-xml line-numbers">&lt;!-- Maven --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
<pre><code class="language-groovy line-numbers">// Gradle
implementation 'org.springframework.boot:spring-boot-starter-actuator'</code></pre>
Add the following properties to the configuration file:
<div>
<pre><code class="language-bash line-numbers"># application.properties
# Expose useful actuator endpoints
management.endpoints.web.exposure.include=health, info, metrics, env, beans

# Info endpoint configuration
management.info.env.enabled=true

# Health endpoint details
management.endpoint.health.show-details=always

# Optional: Customize context path
management.endpoints.web.base-path=/actuator

# Optional: Info Metadata
info.app.name=MySpringBootApp
info.app.description=Spring Boot app with actuator endpoints
info.app.version=1.0.0</code></pre>
</div>
<pre><code class="language-yaml line-numbers"># application.yaml
management:
  endpoints:
      web:
          exposure:
              include: health,info,metrics,env,beans
  info:
      env:
          enabled: true
  endpoint:
      health:
          show-details: always

info:
  app:
      name: "MySpringBootApp"
      description: "Spring Boot app with actuator endpoints"
      version: "1.0.0"</code></pre>
Add the <code data-start="91" data-end="107">UserController</code> (already defined in previous code examples).
<p class="" data-start="1449" data-end="1472">Restart the app and verify the endpoints:</p>

<ul>
    <li data-start="1476" data-end="1517"><code data-start="1476" data-end="1515">http://localhost:8081/myapp/actuator/health</code></li>
    <li data-start="1520" data-end="1559"><code data-start="1520" data-end="1557">http://localhost:8081/myapp/actuator/info</code></li>
    <li data-start="1562" data-end="1604"><code data-start="1562" data-end="1602">http://localhost:8081/myapp/actuator/metrics</code></li>
</ul>
Create a custom health check by implementing <code>HealthIndicator</code>.
<div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@Component
public class CustomHealthIndicator implements HealthIndicator {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public Health health() {
        // perform health check logic (DB ping, dependent server ping, etc.)
        try {
            jdbcTemplate.execute("SELECT 1");
            return Health.up().withDetail("H2 Database", "Available").build();
        } catch (Exception e) {
            return Health.down(e).withDetail("H2 Database", "Unavailable").build();
        }
    }
}</code></pre>
</div>
<h5>Sample cURL Test</h5>
<pre><code class="language-bash line-numbers">$ curl http://localhost:8081/myapp/actuator/info
{"app":{"name":"MySpringBootApp","description":"Spring Boot app with actuator endpoints","version":"1.0.0"}}
$
$ curl http://localhost:8081/myapp/actuator/health
{"status":"UP","components":{"custom":{"status":"UP","details":{"H2 Database":"Available"}},"db":{"status":"UP","details":{"database":"H2","validationQuery":"isValid()"}},"diskSpace":{"status":"UP","details":{"total":245107195904,"free":8402948096,"threshold":10485760,"path":"/Users/srimantasahu/Repo/myapp-gradle/.","exists":true}},"ping":{"status":"UP"},"ssl":{"status":"UP","details":{"validChains":[],"invalidChains":[]}}}}</code></pre>

<hr class="" data-start="733" data-end="736" />

<h2 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">Aspect-Oriented Programming (AOP)</strong></h2>
<p data-start="174" data-end="454"><strong data-start="174" data-end="211">Aspect-Oriented Programming (AOP)</strong> in Spring allows you to <strong data-start="236" data-end="271">separate cross-cutting concerns</strong> like <strong data-start="277" data-end="316">logging, security, and transactions</strong> from your core business logic. Instead of scattering these concerns across multiple classes, you define them in one place as <strong data-start="442" data-end="453">aspects</strong>.</p>
<p data-start="456" data-end="559">Spring AOP uses <strong data-start="472" data-end="495">proxy-based weaving</strong> to apply behavior at runtime without modifying the actual code.</p>

<h4 data-start="561" data-end="599">Common Concepts &amp; Annotations</h4>
<ul>
    <li data-start="602" data-end="687"><strong data-start="602" data-end="612">Aspect</strong> – A class that defines cross-cutting logic using the <code data-start="666" data-end="675">@Aspect</code> annotation.</li>
    <li data-start="690" data-end="766"><strong data-start="690" data-end="700">Advice</strong> – The actual action (e.g., code to run before or after a method).
        <ul>
            <li data-start="771" data-end="812"><code data-start="771" data-end="780">@Before</code> – Run before method execution</li>
            <li data-start="817" data-end="856"><code data-start="817" data-end="825">@After</code> – Run after method execution</li>
            <li data-start="861" data-end="922"><code data-start="861" data-end="870">@Around</code> – Run before and after (can control execution flow)</li>
        </ul>
    </li>
    <li data-start="925" data-end="990"><strong data-start="925" data-end="939">Join Point</strong> – A point in program execution (e.g., method call)</li>
    <li data-start="993" data-end="1071"><strong data-start="993" data-end="1005">Pointcut</strong> – An expression to match join points (e.g., methods in a package)</li>
</ul>
<p data-start="1073" data-end="1234">AOP makes your code cleaner and more modular by letting you apply functionality like logging or transaction management <strong data-start="1192" data-end="1233">without cluttering the business logic</strong>.</p>

<h4>Example</h4>
Add dependencies to <code data-start="430" data-end="439">pom.xml</code> / <code data-start="430" data-end="439">build.gradle</code>:
<div>
<pre><code class="language-xml line-numbers">&lt;!-- Maven --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
<pre><code class="language-groovy line-numbers">// Gradle
implementation 'org.springframework.boot:spring-boot-starter-aop'</code></pre>
<div>

    <code>LoggingAspect</code>
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@Aspect
@Component
public class LoggingAspect {

    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);

    @Before("execution(* com.example.myapp.controller.*.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        logger.info("Entering method: {}", joinPoint.getSignature().toShortString());
    }

    @AfterReturning(pointcut = "execution(* com.example.myapp.controller.*.*(..))", returning = "result")
    public void logAfter(JoinPoint joinPoint, Object result) {
        logger.info("Exiting method: {} with result = {}", joinPoint.getSignature().getName(), result);
    }
}</code></pre>
    </div>
    Restart the application, then run the cURL test again — you’ll notice log entries printed to the console reflecting the aspect-based logging behavior.
    <pre><code class="language-bash line-numbers">[INFO] [LoggingAspect] Entering method: UserController.registerUser(..)
[INFO] [UserService] Finding by username: srimanta
[INFO] [UserService] User 'srimanta' registration successful!
[INFO] [LoggingAspect] Exiting method: registerUser with result = User 'srimanta' registration successful
[INFO] [LoggingAspect] Entering method: UserController.getUserByPath(..)
[INFO] [UserService] Finding by username: srimanta
[INFO] [LoggingAspect] Exiting method: getUserByPath with result = com.example.myapp.model.User@310648fa
</code></pre>
    Breakdown of the <code data-start="492" data-end="508">execution(* com.example.myapp.controller.*.*(..))</code> expression:
    <ul>
        <li><code data-start="611" data-end="614">*</code>: Any return type.</li>
        <li data-start="635" data-end="705"><code data-start="635" data-end="667">com.example.myapp.controller.*</code>: Any class in the controller package.</li>
        <li data-start="708" data-end="764"><code data-start="708" data-end="716">.*(..)</code>: Any method with any number/type of parameters.</li>
    </ul>
    <strong data-start="727" data-end="739">Use Case:</strong> Great for logging entry into controller methods, auth checks, or input validation.

</div>

<hr class="" data-start="733" data-end="736" />

<h2 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">Spring Security</strong></h2>
<p data-start="144" data-end="417"><strong data-start="144" data-end="163">Spring Security</strong> is a comprehensive and customizable framework for handling <strong data-start="223" data-end="241">authentication</strong> and <strong data-start="246" data-end="263">authorization</strong> in Java applications. It helps protect your application from common security threats and simplifies the process of securing both web and REST-based APIs.</p>
<p data-start="419" data-end="474">It supports a variety of security mechanisms including:</p>

<ul>
    <li data-start="477" data-end="516"><strong data-start="477" data-end="516">Form-based and Basic Authentication</strong></li>
    <li data-start="519" data-end="564"><strong data-start="519" data-end="564">OAuth2 and JWT-based token authentication</strong></li>
    <li data-start="567" data-end="596"><strong data-start="567" data-end="596">Role-based access control</strong></li>
    <li data-start="599" data-end="633"><strong data-start="599" data-end="633">Session and stateless security</strong></li>
</ul>
<p data-start="635" data-end="813">Spring Security uses a <strong data-start="658" data-end="674">filter chain</strong> to intercept and process HTTP requests before they reach controllers, allowing fine-grained access control and centralized security logic.</p>

<div>
    <h4>Example</h4>
    Add dependencies to <code data-start="430" data-end="439">pom.xml</code> / <code data-start="430" data-end="439">build.gradle</code>:
    <div>
<pre><code class="language-xml line-numbers">&lt;!-- Maven --&gt;
&lt;!-- Spring Security --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- JWT --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
    &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;
    &lt;version&gt;0.12.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
    &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;
    &lt;version&gt;0.12.6&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
    &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;
    &lt;version&gt;0.12.6&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
    </div>
    <div>
<pre><code class="language-groovy line-numbers">// Gradle
// Spring Boot Starter Security
implementation 'org.springframework.boot:spring-boot-starter-security'

// JWT Dependencies
implementation 'io.jsonwebtoken:jjwt-api:0.12.6'
runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.6'
runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.6'</code></pre>
    </div>
    <code>SecurityConfig</code> Configuration (Lambda DSL)
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Autowired
    private JwtAuthFilter jwtAuthFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -&gt; auth
                        .requestMatchers("/api/users/register", "/api/auth/login", "/error").permitAll()
                        .anyRequest().authenticated()
                )
                .sessionManagement(sm -&gt; sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS));

        http.addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(UserDetailsService uds, PasswordEncoder encoder) throws Exception {
        return new ProviderManager(new DaoAuthenticationProvider() {{
            setUserDetailsService(uds);
            setPasswordEncoder(encoder);
        }});
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}</code></pre>
    </div>
    <code>JWTAuthFilter</code>
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@Component
public class JwtAuthFilter extends OncePerRequestFilter {

    @Autowired
    private JwtService jwtService;

    @Autowired
    private CustomUserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {

        final String authHeader = request.getHeader("Authorization");

        String username = null;
        String jwt = null;

        if (authHeader != null &amp;&amp; authHeader.startsWith("Bearer ")) {
            jwt = authHeader.substring(7);
            username = jwtService.extractUsername(jwt);
        }

        if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) {
            try {
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);

                if (jwtService.validateToken(jwt, userDetails)) {
                    UsernamePasswordAuthenticationToken token =
                            new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                    token.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    SecurityContextHolder.getContext().setAuthentication(token);
                }
            } catch (Exception e) {
                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                response.setContentType("application/json");
                response.getWriter().write("{\"error\": \"" + e.getMessage() + "\"}");
                return;
            }
        }

        chain.doFilter(request, response);
    }
}</code></pre>
    </div>
    <code>JWTService</code>
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@Component
public class JwtService {

    @Value("${jwt.secret}")
    // In Spring, @Value or @ConfigurationProperties fields aren't populated yet when the constructor runs (for field injection).
    private String jwtSecret;

    private SecretKey key;

    @PostConstruct      // Runs after dependency injection is complete (after Spring has populated all fields).
    private void postConstruct() {      // Clean separation: constructor → simple wiring, @PostConstruct → post-wiring logic.
        this.key = Keys.hmacShaKeyFor(Base64.getDecoder().decode(jwtSecret));
    }

    public String generateToken(String username) {
        return Jwts.builder()
                .subject(username)
                .issuedAt(Date.from(Instant.now()))
                .expiration(Date.from(Instant.now().plus(Duration.ofHours(1)))) // 1 hour
                .signWith(key)
                .compact();
    }

    public String extractUsername(String token) {
        return Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload()
                .getSubject();
    }

    public boolean validateToken(String token, UserDetails userDetails) {
        return extractUsername(token).equals(userDetails.getUsername());
    }
}</code></pre>
    </div>
    <code>UserDetailsService</code> Implementation
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional user = userRepository.findUserByUsername(username);

        if (user.isEmpty())
            throw new UsernameNotFoundException("User not found");

        return new org.springframework.security.core.userdetails.User(
                user.get().getUsername(), user.get().getPassword(), new ArrayList&lt;&gt;()
        );
    }
}</code></pre>
    </div>
    <code>UserService</code> (store encoded password)
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@Service
public class UserService {

    private static final Logger logger = LoggerFactory.getLogger(UserService.class);

    @Autowired
    private UserRepository userRepository;

    public String registerUser(UserDTO userDTO) {
        if (findByUsername(userDTO.getUsername()) != null)
            throw new RuntimeException("User already exists");

        String encodedPassword = new BCryptPasswordEncoder().encode(userDTO.getPassword());
        User user = new User(userDTO.getUsername(), userDTO.getEmail(), encodedPassword);

        int update = userRepository.registerUser(user);
        String status = update == 1 ? "successful" : "failed";
        logger.info("User '{}' registration {}!", userDTO.getUsername(), status);
        return "User '" + userDTO.getUsername() + "' registration " + status;
    }

    public User findByUsername(String username) {
        logger.info("Finding by username: {}", username);
        Optional user = userRepository.findUserByUsername(username);
        return user.orElse(null);
    }
}</code></pre>
    </div>
    <code>AuthController</code>
    <div>
<pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @Autowired
    private UserService userService;

    @Autowired
    private JwtService jwtService;

    @Autowired
    private AuthenticationManager authenticationManager;

    @PostMapping("/register")
    public ResponseEntity&lt;?&gt; register(@RequestBody UserDTO userDTO) {
        userService.registerUser(userDTO);
        return ResponseEntity.ok("User registered");
    }

    @PostMapping("/login")
    public ResponseEntity&lt;?&gt; login(@RequestBody UserDTO userDTO) {
        Authentication auth = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(userDTO.getUsername(), userDTO.getPassword()));
        String token = jwtService.generateToken(userDTO.getUsername());
        return ResponseEntity.ok(Collections.singletonMap("token", token));
    }

    @GetMapping("/secure-check")
    public ResponseEntity secureCheck(Principal principal) {
        return ResponseEntity.ok("Accessed secured endpoint by user: " + principal.getName());
    }
}</code></pre>
    </div>
    Add the following properties to the configuration file, then restart the application.
    <div>
<pre><code class="language-bash line-numbers"># application.properties
# Secret Key (YOUR_GENERATED_BASE64_SECRET_KEY)
jwt.secret=wXRc/fUYMb2IAyXRvB4NYzyLws9oimd226c7nqNqs/fT1dbUewJGN/SEuq/5lQROLVDj62NhyR7AhbTI5gY/FA==</code></pre>
        <pre><code class="language-yaml line-numbers"># application.yaml
# Secret Key (YOUR_GENERATED_BASE64_SECRET_KEY)
jwt:
  secret: wXRc/fUYMb2IAyXRvB4NYzyLws9oimd226c7nqNqs/fT1dbUewJGN/SEuq/5lQROLVDj62NhyR7AhbTI5gY/FA==</code></pre>
    </div>
    Generate a secret key like:
    <pre class="lazy-load" data-loaded="false"><code class="language-java line-numbers">byte[] key = new byte[64];
new SecureRandom().nextBytes(key);
System.out.println(Base64.getEncoder().encodeToString(key));</code></pre>
    <h5>Sample cURL Test</h5>
    <pre><code class="language-bash line-numbers">$ curl http://localhost:8081/myapp/api/auth/secure-check
{"timestamp":"2025-05-09T04:47:06.588+00:00","status":403,"error":"Forbidden","path":"/myapp/api/auth/secure-check"}
$
$ curl -X POST http://localhost:8081/myapp/api/users/register \
-H "Content-Type: application/json" \
-d '{
"username": "srimanta",
"email": "srimanta@xmail.com",
"password": "srimanta@123"
}'
User 'srimanta' registration successful
$
$ curl -X POST http://localhost:8081/myapp/api/auth/login \
-H "Content-Type: application/json" \
-d '{
"username": "srimanta",
"password": "srimanta@123"
}'
{"token":"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJzcmltYW50YSIsImlhdCI6MTc0Njc2NjA0OSwiZXhwIjoxNzQ2NzY5NjQ5fQ.9m0xk0PzvfnPG7kfyxjMkNZGhR0Ser7s6zTPEErYrddYBVaZmnmI4_KReEnoL7HHt0HPXGg3_x7cGc99VG7T9w"}
$
$ curl -H "Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJzcmltYW50YSIsImlhdCI6MTc0Njc2NjA0OSwiZXhwIjoxNzQ2NzY5NjQ5fQ.9m0xk0PzvfnPG7kfyxjMkNZGhR0Ser7s6zTPEErYrddYBVaZmnmI4_KReEnoL7HHt0HPXGg3_x7cGc99VG7T9w" http://localhost:8081/myapp/api/auth/secure-check
Accessed secured endpoint by user: srimanta</code></pre>
    <h5>Console Logs</h5>
    <pre><code class="language-bash line-numbers">[INFO] [LoggingAspect] Entering method: UserController.registerUser(..)
[INFO] [UserService] Finding by username: srimanta
[INFO] [UserService] User 'srimanta' registration successful!
[INFO] [LoggingAspect] Exiting method: registerUser with result = User 'srimanta' registration successful
[INFO] [LoggingAspect] Entering method: AuthController.login(..)
[INFO] [LoggingAspect] Exiting method: login with result = &lt;200 OK OK,{token=eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJzcmltYW50YSIsImlhdCI6MTc0Njc2NjA0OSwiZXhwIjoxNzQ2NzY5NjQ5fQ.9m0xk0PzvfnPG7kfyxjMkNZGhR0Ser7s6zTPEErYrddYBVaZmnmI4_KReEnoL7HHt0HPXGg3_x7cGc99VG7T9w},[]&gt;
[INFO] [LoggingAspect] Entering method: AuthController.secureCheck(..)
[INFO] [LoggingAspect] Exiting method: secureCheck with result = &lt;200 OK OK,Accessed secured endpoint by user: srimanta,[]&gt;</code></pre>
</div>

<hr />

<h2 data-pm-slice="1 1 []"><strong>Conclusion</strong></h2>
<p data-pm-slice="1 1 []">Spring empowers Java developers to build clean, maintainable, and scalable applications. With features like IoC, MVC, AOP, security, and powerful configuration management, it provides everything needed for full-stack enterprise development. Mastering these core concepts opens the door to productivity, flexibility, and production-grade performance in real-world applications.</p>


<hr />

[wpcode id="468"]