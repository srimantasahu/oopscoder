<!-- wp:paragraph -->
<p class="" data-start="85" data-end="320">Data structures are the <strong data-start="109" data-end="146">backbone of efficient programming</strong>. Whether you're handling large datasets, optimizing performance, or preparing for coding interviews, understanding Java’s built-in and custom data structures is essential.</p>
<p class="" data-start="322" data-end="595">In this guide, we’ll explore <strong data-start="351" data-end="388">all significant data structures in Java</strong>, from basic arrays to advanced trees and graphs. You'll learn: <br data-start="451" data-end="454" />✔️ When to use each data structure <br data-start="488" data-end="491" />✔️ Code examples for hands-on learning <br data-start="526" data-end="529" />✔️ Real-world use cases </p>
<p class="" data-start="597" data-end="757">By the end of this guide, you'll have a <strong data-start="637" data-end="660">solid understanding</strong> of Java data structures and be able to choose the right one for any problem. Let’s dive in! 🚀</p>
<p data-start="912" data-end="1107">[toc]</p>
<hr class="" data-start="195" data-end="198" />
<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">🔹</strong><strong data-start="267" data-end="284"> </strong><a href="https://en.wikipedia.org/wiki/Array_(data_structure)"><strong data-start="238" data-end="281">Array</strong></a></h3>
<p>A <strong data-start="176" data-end="190">fixed-size</strong>, contiguous memory block that stores elements of the <strong data-start="244" data-end="257">same type</strong>.</p>
<p>Allows <strong data-start="268" data-end="306">constant-time (<code data-start="675" data-end="681">O(1)</code>) random access</strong> using indices.</p>
<p><strong data-start="500" data-end="524">Insertion or removal</strong> (except at the end) requires shifting elements, making it <strong data-start="690" data-end="715"><code data-start="706" data-end="712">O(n)</code></strong>.</p>
<p><strong data-start="423" data-end="435">Example:</strong></p>
<div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">private void array() {
    // Fixed-size array
    int[] array = new int[10];
    array[4] = 5;

    // Dynamic array
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    list.add(1);
    list.addFirst(0);

    System.out.println("Array output:\t array: " + Arrays.toString(array) + ", list: " + list);
    // array: [0, 0, 0, 0, 5, 0, 0, 0, 0, 0], list: [0, 1]
}</code></pre>
</div>
<p><strong data-start="471" data-end="484">Use Case:</strong> <strong>Static lists</strong>, and <strong data-start="447" data-end="463">lookup-heavy</strong> or <strong data-start="467" data-end="485">read-intensive</strong> operations.</p>
<p><strong>Note:</strong> Not dynamically resizable — use <strong data-start="627" data-end="642"><code data-start="629" data-end="640">ArrayList</code></strong> for dynamic data storage with similar performance benefits.</p>
<hr class="" data-start="195" data-end="198" />
<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">🔹</strong><strong data-start="267" data-end="284"> </strong><a href="https://en.wikipedia.org/wiki/String_(computer_science)"><strong data-start="203" data-end="233">String</strong></a></h3>
<p>A <code data-start="173" data-end="181">String</code> is an <strong data-start="188" data-end="224">immutable sequence of characters</strong>, internally implemented as a <strong data-start="254" data-end="284">character array (<code data-start="273" data-end="281">char[]</code>)</strong>.</p>
<p>Once created, a <code data-start="304" data-end="312">String</code> object <strong data-start="320" data-end="342">cannot be modified</strong> — any change results in a <strong data-start="369" data-end="383">new object</strong>.</p>
<p><strong data-start="387" data-end="416">Stored in the String Pool</strong> to save memory and enable reuse of identical string literals.</p>
<p><strong data-start="798" data-end="810">Example:</strong></p>
<div>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">private void string() {
    // Immutable
    String str = "Hello";
    str = str + " World"; // A new object is created, old one is discarded

    // Mutable, fast
    StringBuilder sb = new StringBuilder("Hello");
    sb.append(" ").append("World");

    // Thread-safe
    StringBuffer sbuf = new StringBuffer("Hello");
    sbuf.append(" ").append("World").append('!');

    System.out.println("String output:\t str: " + str + ", sb: " + sb + ", sbuf: " + sbuf);
    // str: Hello World, sb: Hello World, sbuf: Hello World!
}</code></pre>
    </div>
</div>
<p><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="864" data-end="877">Use Case<strong data-start="798" data-end="810">:</strong></strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"><strong> Text processing</strong>, <strong data-start="609" data-end="629">pattern matching</strong>, and <strong data-start="635" data-end="647">encoding</strong> operations.</span></p>
<p><strong>Note:</strong> Immutability aligns with Java’s design goals of <strong data-start="710" data-end="722">security</strong>, <strong data-start="724" data-end="742">predictability</strong>, and <strong data-start="748" data-end="762">robustness</strong>.</p>
<hr class="" data-start="195" data-end="198" />
<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">🔹</strong><strong data-start="267" data-end="284"> </strong><a href="https://en.wikipedia.org/wiki/Linked_list"><strong data-start="533" data-end="570">Linked List</strong></a></h3>
<p>A <strong data-start="194" data-end="220">dynamic data structure</strong> where each element (node) stores data and a <strong data-start="265" data-end="295">reference to the next node</strong>.</p>
<p>Can <strong data-start="303" data-end="329">grow or shrink in size</strong> at runtime — ideal for collections with frequent insertions or deletions.</p>
<p>Supports <strong data-start="415" data-end="462">constant-time (<code data-start="675" data-end="681">O(1)</code>) insertion and deletion</strong> at the head or tail (using iterators or references).</p>
<p>Does <strong data-start="523" data-end="552">not support random access</strong> — lookups require <strong data-start="571" data-end="595">sequential traversal</strong> (<strong data-start="690" data-end="715"><code data-start="706" data-end="712">O(n)</code></strong>).</p>
<p><strong data-start="721" data-end="731">Types of Linked Lists:</strong> </p>
<ul>
    <li data-start="721" data-end="795"><strong data-start="637" data-end="659">Singly Linked List</strong> – Each node points to the next.</li>
    <li data-start="721" data-end="795"><strong data-start="696" data-end="718">Doubly Linked List</strong> – Each node points to both previous and next nodes.</li>
    <li data-start="721" data-end="795"><strong data-start="775" data-end="799">Circular Linked List</strong> – Last node links back to the first.</li>
</ul>
<p><strong data-start="798" data-end="810">Example:</strong></p>
<div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">private void list() {
    // Use ArrayList for fast access (random access) to elements and fewer insertions/removals.
    List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();
    arrayList.add(1);
    arrayList.add(2);

    // Use LinkedList for frequent insertions/deletions at the beginning or middle, but not random access.
    List&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;();
    linkedList.addFirst(5);
    linkedList.add(7);
    linkedList.add(1, 6);

    System.out.println("List output:\t arrayList: [" + arrayList.get(0) + ", " + arrayList.get(1) + "], linkedList: " + linkedList);
    // arrayList: [1, 2], linkedList: [5, 6, 7]
}</code></pre>
</div>
<p><strong data-start="864" data-end="877">Use Case:</strong> <strong>Undo operations</strong>, and <strong>chaining in HashMaps</strong>.</p>
<p><strong>Note:</strong> Preferred over arrays or ArrayLists when <strong data-start="880" data-end="913">modifying elements frequently</strong>, especially at the start or middle.</p>
<hr class="" data-start="195" data-end="198" />
<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">🔹</strong><strong data-start="267" data-end="284"> </strong><a href="https://en.wikipedia.org/wiki/Hash_table"><strong data-start="533" data-end="570">Map</strong></a></h3>
<p>A <strong data-start="149" data-end="182">collection of key-value pairs</strong>, where <strong data-start="190" data-end="212">each key is unique</strong>, and <strong data-start="218" data-end="246">values can be duplicated</strong>.</p>
<p>Provides <strong data-start="259" data-end="297">fast retrieval (<code data-start="675" data-end="681">O(1)</code> average case)</strong> based on keys — ideal for <strong data-start="324" data-end="340">lookup-heavy</strong> use cases.</p>
<p>Keys are <strong data-start="441" data-end="451">hashed</strong> internally (in <code data-start="467" data-end="476">HashMap</code>) for fast access.</p>
<p>Supports different implementations for different needs:</p>
<ul>
    <li data-start="575" data-end="643"><code data-start="560" data-end="569">HashMap</code> – Fast, unordered, allows one <code data-start="600" data-end="606">null</code> key.</li>
    <li data-start="575" data-end="643"><code data-start="619" data-end="634">LinkedHashMap</code> – Maintains insertion order.</li>
    <li data-start="575" data-end="643"><code data-start="671" data-end="680">TreeMap</code> – Sorted by natural order or a custom comparator.</li>
    <li data-start="575" data-end="643"><code data-start="738" data-end="757">ConcurrentHashMap</code> – Thread-safe access for concurrent applications.</li>
</ul>
<p><strong data-start="798" data-end="810">Example:</strong></p>
<div>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">private void map() {
    // HashMap: No order guarantee, fast lookups (O(1))
    Map&lt;Integer, String&gt; hashMap = new HashMap&lt;&gt;();
    hashMap.put(3, "C++");
    hashMap.put(1, "Java");
    hashMap.put(2, "Python");

    // TreeMap: Sorted by keys (Natural Ordering)
    Map&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;(hashMap);

    // LinkedHashMap: Maintains insertion order
    Map&lt;Integer, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();
    linkedHashMap.put(3, "C++");
    linkedHashMap.put(1, "Java");
    linkedHashMap.put(2, "Python");

    System.out.println("Map output:\t\t hashMap: " + hashMap + ", treeMap: " + treeMap + ", linkedHashMap: " + linkedHashMap);
    // hashMap: {1=Java, 2=Python, 3=C++}, treeMap: {1=Java, 2=Python, 3=C++}, linkedHashMap: {3=C++, 1=Java, 2=Python}
}</code></pre>
    </div>
</div>
<p><strong data-start="1939" data-end="1952">Use Case:</strong> <strong>Caching</strong>, <strong data-start="385" data-end="410">configuration storage</strong>, and <strong data-start="416" data-end="428">indexing</strong>.</p>
<hr class="" data-start="195" data-end="198" />
<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">🔹</strong><strong data-start="267" data-end="284"> </strong><a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)"><strong data-start="533" data-end="570">Set</strong></a></h3>
<p>A <strong data-start="151" data-end="198">collection that stores only unique elements</strong> — duplicates are automatically eliminated.</p>
<p>Provides <strong data-start="253" data-end="285">efficient membership testing</strong> using the <code data-start="296" data-end="308">contains()</code> method (average <strong data-start="268" data-end="306"><code data-start="675" data-end="681">O(1)</code></strong> in <code data-start="337" data-end="346">HashSet</code>).</p>
<p>Different implementations in Java:</p>
<ul>
    <li><code data-start="625" data-end="634">HashSet</code> – Unordered, fast, allows one <code data-start="665" data-end="671">null</code> element.</li>
    <li><code data-start="688" data-end="703">LinkedHashSet</code> – Maintains insertion order.</li>
    <li><code data-start="740" data-end="749">TreeSet</code> – Sorted order, based on natural ordering or a custom comparator.</li>
</ul>
<p><strong data-start="798" data-end="810">Example:</strong></p>
<div>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">private void set() {
    // HashSet: Unordered, fast access (O(1)), internally uses a HashMap
    Set&lt;String&gt; hashSet = new HashSet&lt;&gt;();
    hashSet.add("Java");
    hashSet.add("Python");
    hashSet.add("C++");

    // TreeSet: Sorted order (Natural Ordering)
    Set&lt;String&gt; treeSet = new TreeSet&lt;&gt;(hashSet);

    // LinkedHashSet: Maintains insertion order
    Set&lt;String&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();
    linkedHashSet.add("Java");
    linkedHashSet.add("Python");
    linkedHashSet.add("C++");

    System.out.println("Set output:\t\t hashSet: " + hashSet + ", treeSet: " + treeSet + ", linkedHashSet: " + linkedHashSet);
    // hashSet: [Java, C++, Python], treeSet: [C++, Java, Python], linkedHashSet: [Java, Python, C++]
}</code></pre>
    </div>
</div>
<p><strong data-start="2502" data-end="2515">Use Case:</strong> <strong>Removing duplicates</strong>, <strong data-start="386" data-end="404">filtering data</strong>, <strong data-start="526" data-end="551">caching unique values</strong>, and <strong data-start="557" data-end="579">validating entries</strong>.</p>
<hr class="" data-start="195" data-end="198" />
<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">🔹</strong><strong data-start="267" data-end="284"> </strong><a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)"><strong style="font-family: inherit; font-style: inherit;" data-start="924" data-end="950">Stack</strong></a></h3>
<p>Follows the <strong data-start="177" data-end="206">Last-In, First-Out (LIFO)</strong> principle — the last element added is the first to be removed.</p>
<p>Provides <strong data-start="281" data-end="316">constant-time (<code data-start="675" data-end="681">O(1)</code></strong><strong data-start="281" data-end="316">) operations:</strong></p>
<ul>
    <li data-start="955" data-end="997"><code data-start="325" data-end="333">push()</code> – Add element to the top</li>
    <li data-start="955" data-end="997"><code data-start="368" data-end="375">pop()</code> – Remove and return the top element</li>
    <li data-start="955" data-end="997"><code data-start="421" data-end="429">peek()</code> – View the top element without removing it</li>
</ul>
<p><strong data-start="1045" data-end="1057">Example:</strong></p>
<div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">private void stack() {
    // Stack (Legacy API) is a subclass of Vector, which is synchronized and generally slower due to thread safety overhead.
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    stack.push(10);
    stack.pop();

    // ArrayDeque is not synchronized (unlike Stack, which extends Vector) and does not suffer from resizing overhead like an ArrayList-based stack.
    Deque&lt;Integer&gt; arrayDequeAsStack = new ArrayDeque&lt;&gt;(); // Recommended to use as Stack for java implementations
    arrayDequeAsStack.push(10);
    arrayDequeAsStack.push(20);
    arrayDequeAsStack.push(30);
    arrayDequeAsStack.pop();

    System.out.println("Stack output:\t top element: " + arrayDequeAsStack.peek() + ", arrayDequeAsStack:  " + arrayDequeAsStack);
    // top element: 20, arrayDequeAsStack:  [20, 10]
}</code></pre>
</div>
<p><strong data-start="1102" data-end="1115">Use Case:</strong> <strong data-start="498" data-end="525">Backtracking algorithms</strong> (e.g., maze solvers), <strong data-start="551" data-end="575">Function call stacks</strong> in recursion, <strong data-start="593" data-end="606">Undo/redo</strong> operations, and Browser history navigation.</p>
<p><strong>Note:</strong> Use <code data-start="722" data-end="729">Deque</code> (via <code data-start="735" data-end="747">ArrayDeque</code>) for better performance and cleaner usage.</p>
<hr class="" data-start="195" data-end="198" />
<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">🔹</strong><strong data-start="267" data-end="284"> </strong><a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)"><strong data-start="1170" data-end="1214">Queue</strong></a></h3>
<p>Follows the <strong data-start="180" data-end="210">First-In, First-Out (FIFO)</strong> principle — the <strong data-start="227" data-end="277">first element added is the first to be removed</strong>.</p>
<p>Supports primary operations:</p>
<ul>
    <li data-start="1265" data-end="1313"><code data-start="316" data-end="323">add()</code> / <code data-start="326" data-end="335">offer()</code> – Insert element at the rear</li>
    <li data-start="1265" data-end="1313"><code data-start="373" data-end="383">remove()</code> / <code data-start="386" data-end="394">poll()</code> – Remove and return the front element</li>
    <li data-start="1265" data-end="1313"><code data-start="442" data-end="450">peek()</code> – View the front element without removing it</li>
</ul>
<p><strong data-start="1316" data-end="1328">Example:</strong></p>
<div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">private void queue() {
    // LinkedList uses a doubly linked list, which requires O(1) for enqueue/dequeue but has extra memory overhead (pointers for each node).
    // LinkedList suffers from pointer chasing, which increases cache misses and degrades performance.
    Queue&lt;Integer&gt; linkedListAsQueue = new LinkedList&lt;&gt;();
    linkedListAsQueue.add(10);
    linkedListAsQueue.remove();

    // ArrayDeque is backed by a resizable array, providing O(1) time complexity for enqueue (offer/add) and dequeue (poll/remove) operations.
    // ArrayDeque has a better cache locality (since arrays are stored contiguously in memory), making it faster in practice.
    Queue&lt;Integer&gt; arrayDequeAsQueue = new ArrayDeque&lt;&gt;(); // Faster than LinkedList and Recommended to use as Queue for Java implementations
    // Enqueue elements
    arrayDequeAsQueue.offer(10);
    arrayDequeAsQueue.offer(20);
    arrayDequeAsQueue.offer(30);
    // Dequeue elements
    arrayDequeAsQueue.poll();

    System.out.println("Queue output:\t top element: " + arrayDequeAsQueue.peek() + ", arrayDequeAsQueue: " + arrayDequeAsQueue);
    // top element: 20, arrayDequeAsQueue: [20, 30]
}</code></pre>
</div>
<p><strong data-start="1378" data-end="1391">Use Case:</strong> <strong>Task scheduling</strong>, <strong data-start="529" data-end="552">resource management</strong>, and <strong data-start="558" data-end="588">producer-consumer patterns</strong>.</p>
<hr class="" data-start="195" data-end="198" />
<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">🔹</strong><strong data-start="267" data-end="284"> </strong><a href="https://en.wikipedia.org/wiki/Double-ended_queue"><strong data-start="1435" data-end="1479">Deque</strong></a></h3>
<p>Stands for <strong data-start="151" data-end="173">Double-Ended Queue</strong> — allows <strong data-start="183" data-end="237">insertion and removal from both the front and rear</strong>.</p>
<p>Supports all queue and stack operations:</p>
<ul>
    <li data-start="1484" data-end="1552"><code data-start="288" data-end="300">addFirst()</code>, <code data-start="302" data-end="313">addLast()</code></li>
    <li data-start="1484" data-end="1552"><code data-start="322" data-end="337">removeFirst()</code>, <code data-start="339" data-end="353">removeLast()</code></li>
    <li data-start="1484" data-end="1552"><code data-start="363" data-end="376">peekFirst()</code>, <code data-start="378" data-end="390">peekLast()</code></li>
</ul>
<p>Offers <strong data-start="268" data-end="306"><code data-start="675" data-end="681">O(1)</code></strong><strong data-start="400" data-end="424"> time complexity</strong> for add/remove operations on both ends.</p>
<p>In Java, use:</p>
<ul>
    <li data-start="1484" data-end="1552"><code data-start="694" data-end="706">ArrayDeque</code> – high-performance, non-thread-safe</li>
    <li data-start="1484" data-end="1552"><code data-start="747" data-end="759">LinkedList</code> – supports <code data-start="771" data-end="778">Deque</code> but with slightly more overhead</li>
</ul>
<p><strong data-start="1613" data-end="1625">Example:</strong> Refer Stack/Queue example.</p>
<p><strong data-start="1675" data-end="1688">Use Case:</strong> <strong data-start="568" data-end="597">Sliding window algorithms</strong> (e.g., max in window), palindrome checking, and undo/redo buffers.</p>
<hr class="" data-start="1730" data-end="1733" />
<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">🔹</strong><strong data-start="267" data-end="284"> </strong><a href="https://en.wikipedia.org/wiki/Priority_queue"><strong data-start="4110" data-end="4153">Priority Queue</strong></a></h3>
<p>A <strong data-start="165" data-end="221">queue where elements are processed based on priority</strong>, not insertion order.</p>
<p>Internally implemented as a <strong data-start="274" data-end="289">binary heap</strong>, offering:</p>
<ul>
    <li data-start="4158" data-end="4203"><strong><code data-start="4231" data-end="4241">O(log n)</code></strong> insertion and removal</li>
    <li data-start="4158" data-end="4203"><code data-start="1600" data-end="1606"><strong data-start="268" data-end="306">O(1)</strong></code> access to the highest (or lowest) priority element</li>
</ul>
<p>Supports <strong data-start="415" data-end="438">min-heap by default</strong> (smallest element first) – can be configured as a <strong data-start="493" data-end="505">max-heap</strong> using a custom comparator</p>
<p>Key operations:</p>
<ul>
    <li><code data-start="556" data-end="565">offer()</code> / <code data-start="568" data-end="575">add()</code> – inserts with automatic ordering</li>
    <li><code data-start="616" data-end="624">poll()</code> – removes the highest priority element</li>
    <li><code data-start="671" data-end="679">peek()</code> – views the highest priority element</li>
</ul>
<p><strong data-start="4250" data-end="4262">Example:</strong></p>
<div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">private void priorityQueue() {
    PriorityQueue&lt;Integer&gt; priorityQueueAsMinHeap = new PriorityQueue&lt;&gt;(); // Min-Heap
    // Adding elements
    priorityQueueAsMinHeap.offer(30);
    priorityQueueAsMinHeap.offer(10);
    priorityQueueAsMinHeap.offer(20);
    priorityQueueAsMinHeap.offer(5);
    // Removing elements
    priorityQueueAsMinHeap.poll();

    PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Collections.reverseOrder()); // Max-Heap

    System.out.println("Heap output:\t top element: " + priorityQueueAsMinHeap.peek() + ", priorityQueueAsMinHeap: " + priorityQueueAsMinHeap);
    // top element: 10, priorityQueueAsMinHeap: [10, 30, 20]
}</code></pre>
</div>
<p><strong data-start="4320" data-end="4333">Use Case:</strong> Task scheduling, <strong>pathfinding algorithms</strong> like <strong data-start="790" data-end="804">Dijkstra’s</strong>, <strong data-start="809" data-end="827">load balancing</strong> and <strong data-start="832" data-end="846">job queues</strong>.</p>
<hr class="" data-start="1730" data-end="1733" />
<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">🔹</strong><strong data-start="267" data-end="284"> </strong><a href="https://en.wikipedia.org/wiki/Binary_tree"><strong data-start="3221" data-end="3255">Binary Tree</strong></a></h3>
<p>A <strong data-start="178" data-end="201">tree data structure</strong> where each node has at most <strong data-start="230" data-end="246">two children</strong>: <code data-start="248" data-end="254">left</code> and <code data-start="259" data-end="266">right</code>.</p>
<p>Represents <strong data-start="281" data-end="311">hierarchical relationships</strong> and is the foundation for many advanced trees.</p>
<p>Not inherently sorted — structure depends on insertion order.</p>
<p><strong data-start="3367" data-end="3379">Example:</strong></p>
<div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">class TreeNode&lt;T&gt; {
    T data;
    TreeNode&lt;T&gt; left, right;

    public TreeNode(T data) {
        this.data = data;
        this.left = this.right = null;
    }
}

class BinaryTree&lt;T&gt; {
    TreeNode&lt;T&gt; root;

    public BinaryTree(T rootData) {
        this.root = new TreeNode&lt;&gt;(rootData);
    }

    // Inorder Traversal (Left -&gt; Root -&gt; Right)
    public void inorder(TreeNode&lt;T&gt; node) {
        if (node == null) return;
        inorder(node.left);
        System.out.print(node.data + " ");
        inorder(node.right);
    }

    // Level Order Traversal (BFS)
    public void levelOrder() {
        if (root == null) return;

        Queue&lt;TreeNode&lt;T&gt;&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);

        while (!queue.isEmpty()) {
            TreeNode&lt;T&gt; current = queue.poll();
            System.out.print(current.data + " ");

            if (current.left != null) queue.offer(current.left);
            if (current.right != null) queue.offer(current.right);
        }
    }
}

private void tree() {
    // Create a binary tree
    BinaryTree&lt;Integer&gt; tree = new BinaryTree&lt;&gt;(1);
    // Manually create left and right children
    tree.root.left = new TreeNode&lt;&gt;(2);
    tree.root.right = new TreeNode&lt;&gt;(3);
    tree.root.left.left = new TreeNode&lt;&gt;(4);
    tree.root.left.right = new TreeNode&lt;&gt;(5);
    tree.root.right.left = new TreeNode&lt;&gt;(6);
    tree.root.right.right = new TreeNode&lt;&gt;(7);

    System.out.print("Tree output:\t level order traversal: ");
    tree.levelOrder();
    // level order traversal: 1 2 3 4 5 6 7
}</code></pre>
</div>
<p><strong data-start="3466" data-end="3479">Use Case:</strong> <strong data-start="439" data-end="459">Expression trees</strong> (e.g., arithmetic parsing), <strong data-start="491" data-end="505">game trees</strong> (e.g., minimax algorithms), <strong data-start="537" data-end="561">recursive structures</strong> in compilers and interpreters.</p>
<p><strong>Note:</strong> Java doesn't have a built-in <code data-start="884" data-end="896">BinaryTree</code> class — typically implemented via custom <code data-start="938" data-end="944">Node</code> classes with <code data-start="958" data-end="964">left</code> and <code data-start="969" data-end="976">right</code> references.</p>
<hr class="" data-start="1730" data-end="1733" />
<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">🔹</strong><strong data-start="267" data-end="284"> </strong><a href="https://en.wikipedia.org/wiki/Binary_search_tree"><strong data-start="3221" data-end="3255">Binary Search Tree</strong></a></h3>
<p>A <strong data-start="203" data-end="218">binary tree</strong> where each node follows the rule:<br data-start="252" data-end="255" /><strong data-start="257" data-end="292">Left child &lt; Root &lt; Right child</strong></p>
<p>Designed for <strong data-start="308" data-end="348">fast search, insertion, and deletion</strong> operations — average-case <strong data-start="3610" data-end="3665"><code data-start="3652" data-end="3662">O(log n)</code></strong>.</p>
<p>Enables efficient <strong data-start="409" data-end="426">range queries</strong>, <strong data-start="428" data-end="448">sorted traversal</strong>, and <strong data-start="454" data-end="477">duplicate avoidance</strong> (if enforced).</p>
<p>If <strong data-start="498" data-end="512">unbalanced</strong>, performance degrades to <strong data-start="690" data-end="715"><code data-start="706" data-end="712">O(n)</code></strong> — behaves like a linked list.</p>
<p><strong data-start="2160" data-end="2172">Example:</strong></p>
<div>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">class BinarySearchTree {
    private TreeNode&lt;Integer&gt; root;

    public void insert(int key) {
        root = insertElement(root, key);
    }

    private TreeNode&lt;Integer&gt; insertElement(TreeNode&lt;Integer&gt; root, int key) {
        if (root == null) return new TreeNode&lt;&gt;(key);
        if (key &lt; root.data) root.left = insertElement(root.left, key);
        else if (key &gt; root.data) root.right = insertElement(root.right, key);
        return root;
    }

    public boolean search(int key) {
        return searchElement(root, key);
    }

    private boolean searchElement(TreeNode&lt;Integer&gt; root, int key) {
        if (root == null) return false;
        if (key == root.data) return true;
        return key &lt; root.data ? searchElement(root.left, key) : searchElement(root.right, key);
    }

    public void inorder() {
        inorderTraversal(root);
    }

    private void inorderTraversal(TreeNode&lt;Integer&gt; root) {
        if (root != null) {
            inorderTraversal(root.left);
            System.out.print(root.data + " ");
            inorderTraversal(root.right);
        }
    }
}

private void binarySearchTree() {
    BinarySearchTree bst = new BinarySearchTree();
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(2);
    bst.insert(4);
    bst.insert(6);
    bst.insert(8);

    // Displaying the BST (keys are sorted)
    System.out.print("BST output:\t\t search 4: " + bst.search(4) + ", search 7: " + bst.search(7) + ", in-order traversal: ");
    bst.inorder();
    // search 4: true, search 7: false, in-order traversal: 2 3 4 5 6 8 9
}</code></pre>
    </div>
</div>
<p><strong data-start="3707" data-end="3720">Use Case:</strong> <strong data-start="601" data-end="618">Symbol tables</strong>, <strong data-start="620" data-end="642">dictionary lookups</strong>, <strong>sorted data storage</strong>, and <strong>auto-complete suggestions</strong>.</p>
<p><strong>Note:</strong> Java doesn't provide a direct <code data-start="737" data-end="755">BinarySearchTree</code> class — use <code data-start="768" data-end="777">TreeSet</code> or <code data-start="781" data-end="790">TreeMap</code> for built-in BST-based structures (implemented as Red-Black Trees).</p>
<hr class="" data-start="1730" data-end="1733" />
<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">🔹</strong><strong data-start="267" data-end="284"> </strong><a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree"><strong data-start="2001" data-end="2034">Red-Black Tree</strong></a></h3>
<p>A type of <strong data-start="173" data-end="216">self-balancing Binary Search Tree (BST)</strong> that maintains <strong data-start="3610" data-end="3665"><code data-start="3652" data-end="3662">O(log n)</code></strong> time for insertion, deletion, and search.</p>
<p>Ensures balance by enforcing <strong data-start="318" data-end="336">coloring rules</strong> (red/black) and performing <strong data-start="364" data-end="377">rotations</strong> after insertions/deletions.</p>
<p>Guarantees that the tree height is always logarithmic, preventing degeneration into a linked list.</p>
<p>Used internally by Java’s:</p>
<ul>
    <li data-start="2039" data-end="2105"><code data-start="543" data-end="552">TreeMap</code> – sorted key-value storage</li>
    <li data-start="2039" data-end="2105"><code data-start="587" data-end="596">TreeSet</code> – sorted unique element storage</li>
</ul>
<p>Slightly <strong data-start="640" data-end="671">slower lookups than HashMap</strong>, but maintains <strong data-start="687" data-end="703">sorted order</strong> and supports <strong data-start="717" data-end="734">range queries</strong>.</p>
<p><strong data-start="2160" data-end="2172">Example:</strong></p>
<div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">private void redBlackTree() {
    // A TreeMap in Java is a sorted map implementation based on a Red-Black Tree.
    // It maintains keys in sorted order and provides O(log n) time complexity for insertion, deletion, and lookup.
    TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;(); // keys sorted in natural order
    // Adding key-value pairs
    treeMap.put(3, "Three");
    treeMap.put(1, "One");
    treeMap.put(2, "Two");
    treeMap.put(5, "Five");
    treeMap.put(4, "Four");
    // Removing an entry
    treeMap.remove(2);

    Map&lt;Integer, String&gt; descTreeMap = new TreeMap&lt;&gt;(Comparator.reverseOrder()); // keys sorted in descending order

    // Displaying the TreeMap (keys are sorted)
    System.out.println("RedBlackTree:\t first key: " + treeMap.firstKey() + ", last key: " + treeMap.lastKey() + ", treeMap: " + treeMap);
    // first key: 1, last key: 5, treeMap: {1=One, 3=Three, 4=Four, 5=Five}
}</code></pre>
</div>
<p><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="2231" data-end="2244">Use Case<strong data-start="798" data-end="810">:</strong></strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"><strong> Indexing</strong>, <strong>ordered collections</strong>, and <strong>range queries</strong>.</span></p>
<hr class="" data-start="1730" data-end="1733" />
<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">🔹</strong><strong data-start="267" data-end="284"> </strong><a href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type)"><strong data-start="3221" data-end="3255">Graph</strong></a></h3>
<p>A <strong data-start="169" data-end="198">non-linear data structure</strong> used to represent <strong data-start="217" data-end="246">networks or relationships</strong> between entities (nodes/vertices).</p>
<p><strong data-start="284" data-end="293">Edges</strong> represent connections and can be:</p>
<ul>
    <li data-start="2108" data-end="2157"><strong data-start="332" data-end="344">Directed</strong> – edges have direction (e.g., one-way roads)</li>
    <li data-start="2108" data-end="2157"><strong data-start="394" data-end="408">Undirected</strong> – edges have no direction (e.g., mutual friendship)</li>
    <li data-start="2108" data-end="2157"><strong data-start="465" data-end="477">Weighted</strong> – edges have values (e.g., distances, costs)</li>
    <li data-start="2108" data-end="2157"><strong data-start="527" data-end="541">Unweighted</strong> – all edges are treated equally</li>
</ul>
<p>Common representations:</p>
<ul>
    <li><strong data-start="607" data-end="625">Adjacency List</strong> – efficient for <strong data-start="642" data-end="659">sparse graphs</strong>, stores a list of neighbors for each node</li>
    <li><strong data-start="709" data-end="729">Adjacency Matrix</strong> – efficient for <strong data-start="746" data-end="762">dense graphs</strong>, uses a 2D matrix to represent all possible connections</li>
</ul>
<p><strong data-start="2160" data-end="2172">Example:</strong></p>
<div>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">class Graph {
    private final Map&lt;Integer, List&lt;Integer&gt;&gt; adjList;

    public Graph() {
        this.adjList = new HashMap&lt;&gt;();
    }

    // Add a vertex
    public void addVertex(int vertex) {
        adjList.putIfAbsent(vertex, new ArrayList&lt;&gt;());
    }

    // Add an edge (undirected)
    public void addEdge(int src, int dest) {
        adjList.putIfAbsent(src, new ArrayList&lt;&gt;());
        adjList.putIfAbsent(dest, new ArrayList&lt;&gt;());
        adjList.get(src).add(dest);
        adjList.get(dest).add(src);
    }

    // Print the graph
    public void printGraph() {
        for (var entry : adjList.entrySet()) {
            System.out.print(entry.getKey() + " -&gt; " + entry.getValue() + "; ");
        }
    }
}

private void graph() {
    Graph graph = new Graph();
    graph.addVertex(1);
    graph.addVertex(2);
    graph.addVertex(3);
    graph.addVertex(4);
    graph.addEdge(1, 2);
    graph.addEdge(2, 3);
    graph.addEdge(3, 4);
    graph.addEdge(4, 1);

    // Displaying the Graph
    System.out.print("Graph output:\t ");
    graph.printGraph();
    // 1 -&gt; [2, 4]; 2 -&gt; [1, 3]; 3 -&gt; [2, 4]; 4 -&gt; [3, 1];
}</code></pre>
    </div>
</div>
<p><strong data-start="3145" data-end="3158">Use Case:</strong> <strong data-start="834" data-end="853">Social networks</strong> (users connected to users), <strong data-start="885" data-end="899">web graphs</strong> (pages linking to pages), <strong data-start="929" data-end="955">transportation systems</strong> (airports, routes), and <strong data-start="979" data-end="993">algorithms</strong> like BFS, DFS, Dijkstra’s, etc.</p>
<hr class="" data-start="1730" data-end="1733" />
<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">🔹</strong><strong data-start="267" data-end="284"> </strong><a href="https://en.wikipedia.org/wiki/Trie"><strong data-start="3221" data-end="3255">Trie</strong></a></h3>
<p>A <strong data-start="169" data-end="197">tree-like data structure</strong> that stores <strong data-start="210" data-end="239">strings by their prefixes</strong>.</p>
<p>Enables <strong data-start="251" data-end="305">fast lookup, insertion, and prefix-based searching</strong> in <strong><code data-start="6074" data-end="6080">O(m)</code></strong> time, where <strong data-start="330" data-end="335">m</strong> is the length of the key.</p>
<p>Each node represents a <strong data-start="387" data-end="407">single character</strong>, and paths from root to leaf represent full words.</p>
<p>Reduces redundancy by <strong data-start="699" data-end="726">sharing common prefixes</strong>, saving memory over storing full words individually.</p>
<p><strong data-start="2160" data-end="2172">Example:</strong></p>
<div>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">class TrieNode {
    Map&lt;Character, TrieNode&gt; children = new HashMap&lt;&gt;();
    boolean endOfWord;

    public TrieNode() {
        this.endOfWord = false;
    }
}

class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    // Insert a word into the trie
    public void insert(String word) {
        TrieNode node = root;
        for (char ch : word.toCharArray()) {
            node.children.putIfAbsent(ch, new TrieNode());
            node = node.children.get(ch);
        }
        node.endOfWord = true;
    }

    // Search for a word in the trie
    public boolean search(String word) {
        TrieNode node = root;
        for (char ch : word.toCharArray()) {
            if (!node.children.containsKey(ch)) {
                return false;
            }
            node = node.children.get(ch);
        }
        return node.endOfWord;
    }

    // Check if a prefix exists in the trie
    public boolean startsWith(String prefix) {
        TrieNode node = root;
        for (char ch : prefix.toCharArray()) {
            if (!node.children.containsKey(ch)) {
                return false;
            }
            node = node.children.get(ch);
        }
        return true;
    }
}

private void trie() {
    Trie trie = new Trie();
    trie.insert("apple");
    trie.insert("app");
    trie.insert("application");

    System.out.println("Trie output:\t " +
                       "search 'apple': " + trie.search("apple") +
        ", search 'app': " + trie.search("app") +
        ", search 'appl': " + trie.search("appl") +
        ", starts with 'app': " + trie.startsWith("app"));
    // search 'apple': true, search 'app': true, search 'appl': false, starts with 'app': true
}</code></pre>
    </div>
</div>
<p><strong data-start="4014" data-end="4027">Use Case:</strong> <strong>Auto-complete</strong>, <strong>spell checkers</strong>, <strong>word games</strong>, and <strong>dictionary lookups</strong>.</p>
<hr class="" data-start="5001" data-end="5004" />
<h3 style="text-align: left;" data-start="5006" data-end="5029"><strong data-start="5009" data-end="5029">📌 Summary Table</strong></h3>
<div class="overflow-x-auto contain-inline-size responsive-table">
    <table data-start="5030" data-end="6217">
        <thead data-start="5030" data-end="5125">
        <tr data-start="5030" data-end="5125">
            <th data-start="5030" data-end="5051"><strong data-start="5032" data-end="5050">Data Structure</strong></th>
            <th data-start="5051" data-end="5080"><strong data-start="5053" data-end="5079">Implementation in Java</strong></th>
            <th data-start="5080" data-end="5108"><strong data-start="5082" data-end="5107">Time Complexity (Avg)</strong></th>
            <th data-start="5108" data-end="5125"><strong data-start="5110" data-end="5123">Use Cases</strong></th>
        </tr>
        </thead>
        <tbody data-start="5222" data-end="6217">
        <tr data-start="5222" data-end="5336">
            <td><strong data-start="5224" data-end="5233">Array</strong></td>
            <td><code data-start="5236" data-end="5262">int[] arr = new int[10];</code></td>
            <td><code data-start="5265" data-end="5271">O(1)</code> lookup, <code data-start="5280" data-end="5286">O(n)</code> insert/delete</td>
            <td>Static lists, lookup-heavy apps</td>
        </tr>
        <tr data-start="5337" data-end="5449">
            <td><strong data-start="5339" data-end="5354">Linked List</strong></td>
            <td><code data-start="5357" data-end="5372">LinkedList&lt;E&gt;</code></td>
            <td><code data-start="5375" data-end="5381">O(1)</code> insert/delete, <code data-start="5397" data-end="5403">O(n)</code> search</td>
            <td>Undo history, chaining in HashMaps</td>
        </tr>
        <tr data-start="5450" data-end="5520">
            <td><strong data-start="5452" data-end="5461">Stack</strong></td>
            <td><code data-start="5464" data-end="5474">Stack&lt;E&gt;</code></td>
            <td><code data-start="5477" data-end="5483">O(1)</code> push/pop</td>
            <td>Backtracking, recursion</td>
        </tr>
        <tr data-start="5521" data-end="5607">
            <td><strong data-start="5523" data-end="5532">Queue</strong></td>
            <td><code data-start="5535" data-end="5545">Queue&lt;E&gt;</code></td>
            <td><code data-start="5548" data-end="5554">O(1)</code> enqueue/dequeue</td>
            <td>Job scheduling, request handling</td>
        </tr>
        <tr data-start="5608" data-end="5703">
            <td><strong data-start="5610" data-end="5619">Deque</strong></td>
            <td><code data-start="5622" data-end="5632">Deque&lt;E&gt;</code></td>
            <td><code data-start="5635" data-end="5641">O(1)</code> push/pop at both ends</td>
            <td>Sliding window, palindrome checking</td>
        </tr>
        <tr data-start="5704" data-end="5801">
            <td><strong data-start="5706" data-end="5717">HashMap</strong></td>
            <td><code data-start="5720" data-end="5735">HashMap&lt;K, V&gt;</code></td>
            <td><code data-start="5738" data-end="5744">O(1)</code> lookup, <code data-start="5753" data-end="5759">O(n)</code> worst case</td>
            <td>Caching, key-value storage</td>
        </tr>
        <tr data-start="5802" data-end="5875">
            <td><strong data-start="5804" data-end="5815">TreeMap</strong></td>
            <td><code data-start="5818" data-end="5833">TreeMap&lt;K, V&gt;</code></td>
            <td><code data-start="5836" data-end="5846">O(log n)</code></td>
            <td>Sorted key-value storage</td>
        </tr>
        <tr data-start="5876" data-end="5956">
            <td><strong data-start="5878" data-end="5887">Graph</strong></td>
            <td><code data-start="5890" data-end="5906">Adjacency List</code></td>
            <td><code data-start="5909" data-end="5917">O(V+E)</code> traversal</td>
            <td>Networks, shortest paths</td>
        </tr>
        <tr data-start="5957" data-end="6047">
            <td><strong data-start="5959" data-end="5974">Binary Tree</strong></td>
            <td><code data-start="5977" data-end="5987">TreeNode</code></td>
            <td><code data-start="5990" data-end="6000">O(log n)</code> search</td>
            <td>Hierarchical data, expression trees</td>
        </tr>
        <tr data-start="6048" data-end="6125">
            <td><strong data-start="6050" data-end="6058">Trie</strong></td>
            <td><code data-start="6061" data-end="6071">TrieNode</code></td>
            <td><code data-start="6074" data-end="6080">O(m)</code> search</td>
            <td>Auto-complete, dictionary storage</td>
        </tr>
        <tr data-start="6126" data-end="6217">
            <td><strong data-start="6128" data-end="6146">Priority Queue</strong></td>
            <td><code data-start="6149" data-end="6167">PriorityQueue&lt;E&gt;</code></td>
            <td><code data-start="6170" data-end="6180">O(log n)</code></td>
            <td>Scheduling, Dijkstra’s Algorithm</td>
        </tr>
        </tbody>
    </table>
</div>
<hr class="" data-start="6219" data-end="6222" />
<h3 style="text-align: left;" data-start="6224" data-end="6248"><strong data-start="6227" data-end="6248">🚀 Final Thoughts</strong></h3>
<ul>
    <li data-start="116" data-end="178"><strong data-start="116" data-end="126">Arrays:</strong> <code data-start="5265" data-end="5271">O(1)</code> random access, but <code data-start="5397" data-end="5403">O(n)</code> insertion/deletion.</li>
    <li data-start="181" data-end="250"><strong data-start="181" data-end="197">Linked Lists:</strong> <code data-start="5265" data-end="5271">O(1)</code> insert/delete at head/tail, but <code data-start="5397" data-end="5403">O(n)</code> search.</li>
    <li data-start="659" data-end="754"><strong data-start="659" data-end="684">HashMap:</strong> <code data-start="5265" data-end="5271">O(1)</code> average-time operations, but <code data-start="5397" data-end="5403">O(n)</code> worst-case with collisions.</li>
    <li data-start="253" data-end="311"><strong data-start="253" data-end="272">Stacks &amp; Queues:</strong> <code data-start="5265" data-end="5271">O(1)</code> insertion/deletion at one end.</li>
    <li data-start="314" data-end="393"><strong data-start="314" data-end="333">Heaps (Min/Max):</strong> <code data-start="5990" data-end="6000">O(log n)</code> insert/delete due to heap property maintenance.</li>
    <li data-start="396" data-end="484"><strong data-start="396" data-end="404">BSTs:</strong> <code data-start="5990" data-end="6000">O(log n)</code> search/insert/delete (balanced), but <code data-start="5397" data-end="5403">O(n)</code> worst-case if unbalanced.</li>
    <li data-start="396" data-end="484"><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="487" data-end="518">Red-Black Trees<strong data-start="798" data-end="810">:</strong></strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> Always balanced, ensuring <code data-start="5990" data-end="6000">O(log n)</code></span><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> operations.</span></li>
</ul>
<hr class="end-of-content" data-start="5001" data-end="5004" /><!-- /wp:paragraph -->