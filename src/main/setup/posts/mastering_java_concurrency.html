<p class="" data-start="107" data-end="384">Concurrency is a <strong data-start="124" data-end="167">core aspect of modern Java applications</strong>, enabling them to efficiently handle multiple tasks in parallel. Whether you're building <strong data-start="257" data-end="336">high-performance systems, real-time applications, or scalable microservices</strong>, understanding Java concurrency is essential.</p>
<p class="" data-start="386" data-end="910">In this guide, we‚Äôll explore <strong data-start="415" data-end="452">Java‚Äôs concurrency model in depth</strong>, covering <strong data-start="463" data-end="535">threads, synchronization, executors, and advanced locking mechanisms</strong>. You‚Äôll learn:¬†<br data-start="550" data-end="553" />‚úîÔ∏è How <strong data-start="560" data-end="571">threads</strong> work and how to create them efficiently¬†<br data-start="611" data-end="614" />‚úîÔ∏è The role of <strong data-start="629" data-end="648">synchronization</strong> and how to avoid race conditions¬†<br data-start="681" data-end="684" />‚úîÔ∏è How <strong data-start="691" data-end="720">Executors and ThreadPools</strong> improve performance¬†<br data-start="740" data-end="743" />‚úîÔ∏è Advanced concepts like <strong data-start="769" data-end="821">ReentrantLocks, Semaphores, and Atomic variables¬†</strong><br data-start="821" data-end="824" />‚úîÔ∏è Best practices for writing <strong data-start="854" data-end="908">deadlock-free and scalable concurrent applications¬†</strong></p>
<p class="" data-start="912" data-end="1107">With <strong data-start="917" data-end="947">step-by-step code examples</strong> and real-world use cases, this guide will help you <strong data-start="999" data-end="1026">master Java concurrency</strong> and write robust, multi-threaded applications with confidence. üöÄ Let‚Äôs dive in!</p>
<p data-start="912" data-end="1107">[toc]</p>


<hr class="" data-start="771" data-end="774" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ</strong><strong data-start="267" data-end="284"> Thread vs Runnable</strong></h3>
<ul>
    <li class="p1">A <b>thread is a single sequential flow of control</b> and takes an independent path of execution within a program.</li>
    <li class="p1">Threads are basically <b>used to do background processing and parallel processing when the order of execution doesn't matter</b>.</li>
    <li data-start="39" data-end="90">In Java, we can create threads in two main ways
        <ol>
            <li><strong data-start="94" data-end="126">Extending the <code data-start="110" data-end="118">Thread</code> class</strong>
                <ul>
                    <li data-start="94" data-end="128">The class directly inherits from <code data-start="435" data-end="443">Thread</code> and overrides the <code data-start="462" data-end="469">run()</code> method.</li>
                    <li data-start="94" data-end="128">The <code data-start="484" data-end="493">start()</code> method is used to begin execution in a separate thread.</li>
                </ul>
            </li>
            <li data-start="132" data-end="175"><strong data-start="132" data-end="173">Implementing the <code data-start="151" data-end="161">Runnable</code> interface</strong>
                <ul>
                    <li data-start="132" data-end="175">The class implements <code data-start="1269" data-end="1279">Runnable</code> and overrides the <code data-start="1298" data-end="1305">run()</code> method.</li>
                    <li data-start="132" data-end="175">The <code data-start="1320" data-end="1328">Thread</code> class is used to execute the <code data-start="1358" data-end="1368">Runnable</code> instance.</li>
                </ul>
            </li>
        </ol>
    </li>
</ul>
<ul>
    <li><strong data-start="798" data-end="810">Example:</strong></li>
</ul>
<div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">static class MyThread extends Thread {
    public void run() {
        System.out.println("MyThread's thread: " + Thread.currentThread().getName());
    }
}

static class MyRunnable implements Runnable {
    public void run() {
        System.out.println("MyRunnable's thread: " + Thread.currentThread().getName());
    }
}</code></pre>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">/* *** *** *** *** *** test code *** *** *** *** *** */
System.out.println("Current thread: " + Thread.currentThread().getName());
// Current thread: main

MyThread t1 = new MyThread();
t1.start(); // Starts a new thread
// MyThread's thread: Thread-0

Thread t2 = new Thread(new MyRunnable());
t2.start(); // Starts a new thread
// MyRunnable's thread: Thread-1</code></pre>
    </div>
</div>
<ul>
    <li>Using <code data-start="512" data-end="522">Runnable</code> is generally preferred as it promotes better design by <strong data-start="578" data-end="633">separating the task from the thread execution logic</strong>, making the code more flexible (e.g., allows extending other classes) and maintainable.</li>
</ul>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Synchronized Keyword</strong></h3>
<ul>
    <li data-start="62" data-end="210">The <code data-start="66" data-end="80">synchronized</code> keyword in Java is used to <strong data-start="108" data-end="135">prevent race conditions</strong> when multiple threads try to access shared resources <strong data-start="189" data-end="209">at the same time</strong>. It ensures that <strong data-start="228" data-end="247">only one thread</strong> can execute a block of code or method <strong data-start="286" data-end="299">at a time</strong>, keeping data <strong data-start="314" data-end="337">safe and consistent</strong> in multithreaded environments.</li>
    <li data-start="62" data-end="210">Two Ways to Use <code data-start="586" data-end="600">synchronized</code>
        <ol>
            <li data-start="62" data-end="210"><strong>Synchronized Method</strong>
                <ul>
                    <li data-start="62" data-end="210">Locks on the object (<code data-start="657" data-end="663">this</code>) for instance methods or on the class for static methods.</li>
                </ul>
            </li>
            <li data-start="62" data-end="210"><strong>Synchronized Block</strong>
                <ul>
                    <li data-start="62" data-end="210">Allows us to synchronize <strong data-start="1057" data-end="1065">part</strong> of a method, giving more fine-grained control.</li>
                </ul>
            </li>
        </ol>
    </li>
    <li><strong data-start="798" data-end="810">Example:</strong></li>
</ul>
<div>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">static class SharedResource {
    private final Object lock = new Object();
    private int count = 1;

    public synchronized void incrementUsingSynchronizedMethod() {
        for (int i = 1; i &lt;= 3; i++) {
            System.out.println("[Synchronized Method] " + Thread.currentThread().getName() + ": " + count++);
        }
    }

    public void incrementUsingSynchronizedBlock() {
        synchronized (this) {
            for (int i = 1; i &lt;= 3; i++) {
                System.out.println("[Synchronized Block] " + Thread.currentThread().getName() + ": " + count++);
            }
        }
    }

    public void incrementUsingSynchronizedLockObject() {
        synchronized (lock) {
            for (int i = 1; i &lt;= 3; i++) {
                System.out.println("[Synchronized Lock Object] " + Thread.currentThread().getName() + ": " + count++);
            }
        }
    }
}</code></pre>
    </div>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">/* *** *** *** *** *** test code *** *** *** *** *** */
SharedResource resource = new SharedResource();
new Thread(resource::incrementUsingSynchronizedMethod).start();
new Thread(resource::incrementUsingSynchronizedBlock).start();
new Thread(resource::incrementUsingSynchronizedLockObject).start();

// [Synchronized Method] Thread-2: 1
// [Synchronized Lock Object] Thread-4: 2
// [Synchronized Method] Thread-2: 3
// [Synchronized Lock Object] Thread-4: 4
// [Synchronized Method] Thread-2: 5
// [Synchronized Lock Object] Thread-4: 6
// [Synchronized Block] Thread-3: 7
// [Synchronized Block] Thread-3: 8
// [Synchronized Block] Thread-3: 9</code></pre>
    </div>
</div>
<ul>
    <li>¬†Note that Synchronized Method and Synchronized Block are using the same shared lock¬†(<code data-start="657" data-end="663">this</code>), so the second one (i.e., <code data-start="657" data-end="663">Thread-3</code>) starts after the first thread (i.e., <code data-start="657" data-end="663">Thread-2</code>) releases the lock.</li>
</ul>

<hr class="" data-start="771" data-end="774" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ</strong><strong data-start="267" data-end="284"> wait(), notify(), and join()</strong></h3>
<ul>
    <li><strong><code>wait()</code></strong><strong>:</strong> Releases the lock and makes the thread <strong>wait</strong>¬†until another thread calls¬†<code>notify()</code>.</li>
    <li><strong><code>notify()</code></strong><strong data-start="798" data-end="810">:</strong> Wakes up <strong>one</strong>¬†waiting thread (randomly chosen).</li>
    <li><strong><code>notifyAll()</code></strong><strong data-start="798" data-end="810">:</strong> Wakes up <strong>all</strong>¬†waiting threads.</li>
    <li><strong><code>join()</code></strong><strong data-start="798" data-end="810">:</strong> <strong>Waits for a thread to complete</strong>¬†before proceeding.</li>
    <li><strong data-start="798" data-end="810">Example:</strong></li>
</ul>
<div>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">static class SimpleProducerConsumer {
    private int data;
    private boolean ready = false;

    public synchronized void produce(int value) {
        System.out.println("Producer: Producing data = " + value);
        data = value;
        ready = true;
        notify(); // Notify the waiting consumer
        System.out.println("Producer: Data produced and notified.");
    }

    public synchronized int consume() throws InterruptedException {
        while (!ready) {
            System.out.println("Consumer: Waiting for data...");
            wait(); // Wait until data is produced
        }
        System.out.println("Consumer: Data received = " + data);
        return data;
    }
}</code></pre>
    </div>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">/* *** *** *** *** *** test code *** *** *** *** *** */
SimpleProducerConsumer simpleProducerConsumer = new SimpleProducerConsumer();

Thread producer = new Thread(() -&gt; {
    try {
        Thread.sleep(1000); // Simulate delay of 1000 ms
        simpleProducerConsumer.produce(19);
    } catch (InterruptedException e) { /* handle it */ }
});

Thread consumer = new Thread(() -&gt; {
    try {
        int received = simpleProducerConsumer.consume();
    } catch (InterruptedException e) { /* handle it */ }
});

producer.start(); // Starts Producer thread
consumer.start(); // Starts Consumer thread

// Use join() to wait for both threads to finish
producer.join(); // Main thread waits for producer to finish
consumer.join(); // Main thread waits for consumer to finish

System.out.println("Main thread: Producer and Consumer finished.");

// Consumer: Waiting for data...
// Producer: Producing data...
// Producer: Data produced and notified.
// Consumer: Data received = 19
// Main thread: Producer and Consumer finished.</code></pre>

        <hr class="" data-start="733" data-end="736" />

        <h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ LockSupport</strong></h3>
        <ul>
            <li>Provides<strong data-start="250" data-end="286"> basic thread blocking primitives</strong>. It's a more flexible alternative to <code data-start="324" data-end="339">Object.wait()</code>/<code data-start="340" data-end="350">notify()</code> or even <code data-start="359" data-end="375">Thread.sleep()</code>.</li>
            <li><strong>Key Features</strong>
                <ul>
                    <li><strong>Park/unpark</strong>¬†threads (alternative to¬†<code>wait()</code>/<code>notify()</code>)</li>
                    <li><strong>No monitor requirement</strong>¬†(unlike synchronized blocks)</li>
                    <li><strong>Permit-based</strong>¬†(1 permit per thread)</li>
                    <li><strong data-start="657" data-end="691">Unpark before park still works</strong> (token-style behavior)</li>
                </ul>
            </li>
            <li><strong data-start="798" data-end="810">Example:</strong></li>
        </ul>
        <div>
            <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">Thread worker1 = new Thread(() -&gt; {
    System.out.println("WorkerThread-1: Waiting to be unparked...");
    LockSupport.park();  // thread will block here
    System.out.println("WorkerThread-1: Unparked and resumed.");
});

worker1.start();

try {
    Thread.sleep(1000); /* Simulate delay */
} catch (InterruptedException e) { /* handle it */ }

System.out.println("Main thread: Unparking worker thread.");
LockSupport.unpark(worker1);  // unblock the worker thread

// WorkerThread-1: Waiting to be unparked...
// Main thread: Unparking worker thread.
// WorkerThread-1: Unparked and resumed.

Thread worker2 = new Thread(() -&gt; {
    System.out.println("WorkerThread-2: Started execution...");
    try {
        Thread.sleep(1000); /* Simulate delay */
    } catch (InterruptedException e) { /* handle it */ }
    System.out.println("WorkerThread-2: Parking worker thread.");
    LockSupport.park(); // will not block because it was already unparked
    System.out.println("WorkerThread-2: Resumes immediately!");
});

worker2.start();
LockSupport.unpark(worker2); // pre-unpark ‚Äî gives a "permit" before actual parking
System.out.println("Main thread: Unparked worker thread.");

// Main thread: Unparked worker thread.
// WorkerThread-2: Started execution...
// WorkerThread-2: Parking worker thread.
// WorkerThread-2: Resumes immediately!</code></pre>
            </div>
        </div>
        <ul>
            <li><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">Use Case: </strong>Custom locks, Task scheduling, Timeouts without <code data-start="876" data-end="892">Thread.sleep()</code><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">.</span></li>
            <li><strong>Note:</strong> <strong>Prefer over wait()/notify()</strong> for low-level synchronization.</li>
        </ul>
    </div>
</div>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Thread Lifecycle</strong></h3>
<ul>
    <li data-start="579" data-end="613"><strong data-start="579" data-end="587">NEW:</strong> Thread is <strong>created but not started</strong>¬†(<code>start()</code>¬†not called yet).</li>
    <li data-start="619" data-end="664"><strong data-start="619" data-end="632">RUNNABLE</strong><strong data-start="579" data-end="587">:</strong> Thread is <strong>ready to run</strong>¬†(after calling¬†<code>start()</code>) but may not be executing yet (depends on the OS scheduler).</li>
    <li data-start="670" data-end="737"><strong data-start="670" data-end="690">BLOCKED:</strong> Thread is¬†<strong>waiting for a monitor lock</strong>¬†(e.g., trying to enter a¬†<code>synchronized</code>¬†block).</li>
    <li><strong data-start="670" data-end="690">WAITING</strong><strong data-start="579" data-end="587">:</strong> Thread <strong>waits indefinitely</strong>¬†for another thread to notify it (via¬†<code>wait()</code>,¬†<code>join()</code>, or¬†<code>LockSupport.park()</code>).</li>
    <li data-start="743" data-end="798"><strong data-start="743" data-end="761">TIMED_WAITING</strong><strong data-start="579" data-end="587">:</strong> Thread <strong>waits for a specified time</strong>¬†(via¬†<code>sleep(time)</code>,¬†<code>wait(timeout)</code>,¬†<code>join(timeout)</code>).</li>
    <li data-start="804" data-end="841"><strong data-start="804" data-end="819">TERMINATED</strong><strong data-start="579" data-end="587">:</strong> Thread <strong>has finished execution</strong>¬†(<code>run()</code>¬†method completed).</li>
</ul>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Volatile Keyword</strong></h3>
<ul>
    <li data-start="176" data-end="229">In multithreaded programs, threads can <strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="419" data-end="438">cache variables</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> locally (in CPU registers or thread stacks) for performance.¬†</span></li>
    <li data-start="176" data-end="229">The <code data-start="180" data-end="190">volatile</code> keyword tells the <strong data-start="209" data-end="228">JVM and threads</strong>
        <ul>
            <li>‚ÄúHey! This variable is shared between threads, so don‚Äôt cache it. Always read and write directly from main memory.‚Äù</li>
        </ul>
    </li>
    <li data-start="176" data-end="229">Without <code style="font-size: inherit;" data-start="509" data-end="519">volatile</code><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">, a thread might keep </span><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="541" data-end="566">reading a stale value</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> ‚Äî never seeing the latest value written by another thread.</span></li>
    <li><strong data-start="798" data-end="810">Example:</strong></li>
</ul>
<div>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">static class Worker {
    private volatile boolean running = true;  // visible across threads

    public void run() {
        System.out.println(Thread.currentThread().getName() + ": started.");
        while (running) { /* simulate some work */ }
        // stops when running=false (reads from main memory)
        System.out.println(Thread.currentThread().getName() + ": stopped.");
    }

    public void stopRunning() {
        running = false;
    }
}</code></pre>
    </div>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">/* *** *** *** *** *** test code *** *** *** *** *** */
Worker worker = new Worker();
Thread t3 = new Thread(worker::run);
t3.start();

// let the thread t3 run for 2 seconds
Thread.sleep(2000);

System.out.println("Main thread: stopping worker...");
worker.stopRunning();

// wait for the worker to finish
t3.join();
System.out.println("Main thread: worker has stopped.");

// Thread-5: started.
// Main thread: stopping worker...
// Thread-5: stopped.
// Main thread: worker has stopped.</code></pre>
    </div>
</div>
<ul>
    <li><strong data-start="727" data-end="739">Use Case:</strong>¬†One thread <strong data-start="2115" data-end="2125">writes</strong>, and many threads <strong data-start="2144" data-end="2152">read</strong>. We need to communicate <strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="2180" data-end="2189">flags</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">, like: </span><code data-start="2201" data-end="2212">isRunning</code>,¬†<code data-start="2217" data-end="2229">isShutdown</code>,¬†<code data-start="2234" data-end="2246">shouldStop</code>.</li>
</ul>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Atomic Variables</strong></h3>
<ul>
    <li class="p1">Provide <strong data-start="193" data-end="206">lock-free</strong>, <strong data-start="208" data-end="223">thread-safe</strong> operations on single variables.</li>
    <li>Use <strong data-start="355" data-end="388">CPU-level atomic instructions</strong>, like Compare-And-Swap (CAS), to ensure thread safety without <code data-start="451" data-end="465">synchronized</code>.</li>
    <li class="p1">Common types ‚Äì <code data-start="273" data-end="288">AtomicInteger</code>,¬†<code data-start="291" data-end="303">AtomicLong</code>,¬†<code data-start="306" data-end="321">AtomicBoolean</code>,¬†<code data-start="324" data-end="344">AtomicReference&lt;T&gt;</code></li>
    <li class="p1">Supports atomic operations like <code data-start="95" data-end="114">incrementAndGet()</code> ‚Äì Atomic counter increment, <code data-start="148" data-end="181">compareAndSet(expected, update)</code> ‚Äì Conditional update (CAS), etc.</li>
    <li><strong data-start="798" data-end="810">Example:</strong></li>
</ul>
<div>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">AtomicInteger counter = new AtomicInteger(0);
AtomicBoolean printed = new AtomicBoolean(false);

Runnable task = () -&gt; {
    for (int i = 0; i &lt; 2; i++) {
        int current = counter.incrementAndGet();
        System.out.println(Thread.currentThread().getName() + ": Count = " + current);

        // Only one thread prints this when count reaches 1
        if (current &gt;= 1 &amp;&amp; printed.compareAndSet(false, true))
            System.out.println(Thread.currentThread().getName() + ": Count reached 1! (printed only once)");

        // Simulate delay
        try { Thread.sleep(100); } catch (InterruptedException e) { /* handle it */ }
    }
};

Thread t4 = new Thread(task, "Thread-1");
Thread t5 = new Thread(task, "Thread-2");

t4.start(); t5.start();
t4.join(); t5.join();

System.out.println("Main thread: Final Count = " + counter.get());

// Thread-2: Count = 2
// Thread-1: Count = 1
// Thread-2: Count reached 1! (printed only once)
// Thread-1: Count = 3
// Thread-2: Count = 4
// Main thread: Final Count = 4</code></pre>
    </div>
</div>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Reentrant Lock</strong></h3>
<ul>
    <li><strong data-start="318" data-end="331">Reentrant</strong> means - the same thread can acquire the same lock multiple times without getting blocked or causing a deadlock.</li>
    <li>
        <div>Provides <strong data-start="244" data-end="264">explicit locking</strong> with more features than the <code data-start="293" data-end="307">synchronized</code> keyword.</div></li>
    <li><strong>Key Features</strong>
        <ul>
            <li><strong>Try-lock:</strong>¬†attempt to acquire lock without blocking</li>
            <li><strong>Fairness policy: </strong>prevents thread starvation</li>
            <li><strong>Condition support: </strong>for complex wait/notify scenarios</li>
        </ul>
    </li>
    <li><strong data-start="798" data-end="810">Example:</strong></li>
</ul>
<div>
    <div>
        <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">static class SimplePrinterQueue {

    private final ReentrantLock lock = new ReentrantLock(true); // fair lock
    private final Condition colorQueue = lock.newCondition();
    private final Condition bwQueue = lock.newCondition();
    private boolean printerBusy = false;

    public void printJob(String jobType) {
        boolean acquired = false;
        try {
            // Try to acquire lock with timeout
            acquired = lock.tryLock(1, TimeUnit.SECONDS);
            if (!acquired) {
                System.out.println(Thread.currentThread().getName() + ": Could not acquire lock. Skipping " + jobType + " job.");
                return;
            }

            Condition currentCondition = jobType.equals("color") ? colorQueue : bwQueue;

            // Wait if printer is busy
            while (printerBusy) {
                System.out.println(Thread.currentThread().getName() + ": Waiting in " + jobType + " queue.");
                currentCondition.await(); // wait until printer is busy
            }

            // Proceed to print
            printerBusy = true;
            System.out.println(Thread.currentThread().getName() + ": Printing a " + jobType + " job...");
            Thread.sleep(500); // simulate print time

            printerBusy = false;
            System.out.println(Thread.currentThread().getName() + ": Finished printing.");

            // Notify all waiting threads
            colorQueue.signal();
            bwQueue.signal();

        } catch (InterruptedException e) {
            // handle it
        } finally {
            if (acquired) {
                lock.unlock();
            }
        }
    }
}</code></pre>
            <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">/* *** *** *** *** *** test code *** *** *** *** *** */
SimplePrinterQueue printer = new SimplePrinterQueue();

Runnable colorTask = () -&gt; printer.printJob("color");
Runnable bwTask = () -&gt; printer.printJob("bw");

for (int i = 0; i &lt; 2; i++) {
    new Thread(colorTask, "ColorThread-" + i).start();
    new Thread(bwTask, "BWThread-" + i).start();
}

// ColorThread-0: Printing a color job...
// ColorThread-0: Finished printing.
// BWThread-0: Printing a bw job...
// BWThread-1: Could not acquire lock. Skipping bw job.
// ColorThread-1: Could not acquire lock. Skipping color job.
// BWThread-0: Finished printing.</code></pre>
            </div>
        </div>
    </div>
    <div>
        <ul>
            <li><strong>Best Practices</strong>
                <ul>
                    <li>Use try-lock to avoid deadlocks.</li>
                    <li>Always release lock in¬†<code>finally</code> block.</li>
                    <li>Consider fairness only if thread starvation is a concern.</li>
                </ul>
            </li>
        </ul>

        <hr class="" data-start="733" data-end="736" />

        <h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Semaphore</strong></h3>
        <ul>
            <li>A synchronization mechanism that <strong>controls access to shared resources through permits</strong>.</li>
            <li>Allows a limited number of threads to access a particular section of code or resource at the same time.</li>
            <li><strong data-start="798" data-end="810">Example:</strong></li>
        </ul>
        <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">static class DatabaseConnectionPool {
    private static final int MAX_CONNECTIONS = 3;
    private final Semaphore semaphore = new Semaphore(MAX_CONNECTIONS, true); // Fair semaphore (i.e. first-come-first-served)

    public void connect() {
        try {
            semaphore.acquire(); // Wait for a permit
            System.out.println(Thread.currentThread().getName() + ": Connected");
            Thread.sleep(2000); // Simulate database work
        } catch (InterruptedException e) { /* handle it */
        } finally {
            System.out.println(Thread.currentThread().getName() + ": Disconnected");
            semaphore.release(); // Release the permit
        }
    }
}</code></pre>
            <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">/* *** *** *** *** *** test code *** *** *** *** *** */
DatabaseConnectionPool pool = new DatabaseConnectionPool();

// Create 5 threads trying to connect
for (int i = 0; i &lt; 5; i++) {
    new Thread(pool::connect, "DatabaseConnectionPoolThread-" + i).start();
}

// DatabaseConnectionPoolThread-0: Connected
// DatabaseConnectionPoolThread-2: Connected
// DatabaseConnectionPoolThread-1: Connected
// DatabaseConnectionPoolThread-2: Disconnected
// DatabaseConnectionPoolThread-1: Disconnected
// DatabaseConnectionPoolThread-4: Connected
// DatabaseConnectionPoolThread-0: Disconnected
// DatabaseConnectionPoolThread-3: Connected
// DatabaseConnectionPoolThread-4: Disconnected
// DatabaseConnectionPoolThread-3: Disconnected</code></pre>
            </div>
        </div>
        <ul>
            <li><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">Use Case: </strong><strong>Resource Pooling</strong>¬†(Database connections, thread pools)<span style="font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">, </span><strong>Rate Limiting</strong> (allow only N concurrent requests), <strong>Producer-Consumer</strong>¬†(Bounded buffer problem)<span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">.</span></li>
        </ul>
    </div>
</div>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Fork and Join Framework</strong></h3>
<ul>
    <li>Designed to <strong data-start="92" data-end="119">leverage multiple cores</strong> efficiently, especially for <strong data-start="148" data-end="186">parallel, divide-and-conquer tasks</strong>.</li>
    <li>Supports <strong data-start="2761" data-end="2778">work-stealing</strong> (idle threads "steal" tasks from busy ones) to optimize multi-core processor utilization.</li>
    <li><strong>Key Classes</strong>
        <ul>
            <li><strong><code>ForkJoinPool</code></strong><strong data-start="579" data-end="587">:</strong> A special thread pool for running <code>ForkJoinTask</code>s</li>
            <li><strong><code>RecursiveTask&lt;V&gt;</code></strong><strong data-start="579" data-end="587">:</strong> Use for task that <strong data-start="807" data-end="827">returns a result</strong></li>
            <li><strong><code>RecursiveAction</code></strong><strong data-start="579" data-end="587">:</strong> Use for task that <strong data-start="871" data-end="899">does not return a result</strong></li>
        </ul>
    </li>
    <li><strong data-start="798" data-end="810">Example:</strong></li>
</ul>
<div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">static class SumTask extends RecursiveTask&lt;Long&gt; {
    private static final int THRESHOLD = 3;
    private final int[] arr;
    private final int start, end;

    public SumTask(int[] arr, int start, int end) {
        this.arr = arr;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if (end - start &lt;= THRESHOLD) {
            // Base case: sum directly
            long sum = 0;
            for (int i = start; i &lt; end; i++) sum += arr[i];
            return sum;
        } else {
            // Fork
            int mid = (start + end) / 2;
            SumTask left = new SumTask(arr, start, mid);
            SumTask right = new SumTask(arr, mid, end);

            left.fork();    // run left asynchronously
            long rightResult = right.compute(); // compute right directly
            long leftResult = left.join();  // wait for left

            return leftResult + rightResult;
        }
    }
}</code></pre>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">/* *** *** *** *** *** test code *** *** *** *** *** */
int[] array = new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

try (ForkJoinPool pool = ForkJoinPool.commonPool()) {
    SumTask sumTask = new SumTask(array, 0, array.length);

    long result = pool.invoke(sumTask);
    System.out.println("Sum of [1..10] = " + result);
}

// Sum of [1..10] = 55</code></pre>
        <div>
            <ul>
                <li><strong>Performance Tips</strong>:
                    <ul>
                        <li><strong>Set a good threshold</strong>¬†(too small ‚Üí overhead, too large ‚Üí underutilization).</li>
                        <li><strong>Avoid blocking calls</strong>¬†in tasks (defeats work-stealing).</li>
                        <li><strong>Use¬†<code>commonPool()</code></strong> instead of creating new ForkJoinPool().</li>
                    </ul>
                </li>
                <li><strong>Use Case</strong>: Merge sort, Tree traversal, Matrix operations.</li>
            </ul>
        </div>
    </div>
</div>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Executor Framework</strong></h3>
<ul>
    <li>A powerful set of <strong data-start="157" data-end="183">interfaces and classes</strong> in Java used to manage and control <strong data-start="219" data-end="230">threads</strong> more efficiently and cleanly than using <code data-start="271" data-end="279">Thread</code> directly.</li>
    <li>It simplifies - Thread creation and management, Task submission, and Concurrency handling.</li>
    <li>Key components in Executor Framework are:</li>
</ul>
<h4 data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ </strong>Executor</h4>
<ul>
    <li>Basic interface to execute a task.</li>
    <li>Think of it as a way to <strong data-start="645" data-end="688">decouple task submission from execution</strong>.</li>
    <li><strong>Key method</strong>
        <ul>
            <li><code data-start="861" data-end="871">void execute(Runnable command)</code> ‚Äì<span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">¬†submits a fire-and-forget task</span></li>
        </ul>
    </li>
    <li><strong data-start="798" data-end="810">Example:</strong></li>
</ul>
<div>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">Executor executor = Executors.newSingleThreadExecutor();
executor.execute(() -&gt; System.out.println("Running in background"));
((ExecutorService) executor).shutdown();    // Hack to shut down the executor

// Running in background</code></pre>

        <hr class="" data-start="733" data-end="736" />

    </div>
    <h4 data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ </strong>Future</h4>
    <ul>
        <li>Represents the¬†<strong>result of an asynchronous computation</strong>.</li>
        <li><strong>Key methods</strong>
            <ul>
                <li><code data-start="861" data-end="871">get()</code> ‚Äì blocks until result is available</li>
                <li><code data-start="861" data-end="871">get(timeout, unit)</code> ‚Äì waits with a timeout</li>
                <li><code data-start="861" data-end="871">isDone()</code> ‚Äì checks if computation is complete</li>
                <li><code data-start="1327" data-end="1337">cancel()</code> ‚Äì attempts cancellation</li>
            </ul>
        </li>
        <li>Limited functionality (no chaining or composition).</li>
    </ul>

    <hr class="" data-start="733" data-end="736" />

</div>
<h4 data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ </strong>ExecutorService</h4>
<ul>
    <li>Manages a pool of threads and provides lifecycle methods.</li>
    <li>Extends <code data-start="861" data-end="871">Executor</code> with methods
        <ul>
            <li><code data-start="880" data-end="890">submit(Callable task)</code> ‚Äì submits a value-returning task</li>
            <li><code data-start="956" data-end="969">invokeAll()</code>|<code data-start="971" data-end="984">invokeAny()</code> ‚Äì for batch task execution</li>
            <li><code data-start="913" data-end="925">shutdown()</code> ‚Äì graceful shutdown</li>
            <li><code data-start="956" data-end="969">awaitTermination()</code> ‚Äì waits for shutdown</li>
        </ul>
    </li>
    <li><strong data-start="798" data-end="810">Example:</strong></li>
</ul>
<div>
    <div>
        <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">static class MyCallable implements Callable&lt;Integer&gt; {

    @Override
    public Integer call() throws Exception {
        Thread.sleep(1000); // sleeps for a second
        return 1;
    }
}</code></pre>
        </div>
    </div>
    <div>
        <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">ExecutorService executorService = Executors.newFixedThreadPool(2);
Future&lt;Integer&gt; future = executorService.submit(new MyCallable());
System.out.println("Task done: " + future.isDone());    // false
System.out.println("Future result: " + future.get());   // blocks until the task is done, then prints 1
executorService.shutdown();

// Task done: false
// Future result: 1</code></pre>

            <hr class="" data-start="733" data-end="736" />

        </div>
    </div>
</div>
<h4 data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ </strong>ScheduledExecutorService</h4>
<ul>
    <li>Allows to <strong data-start="1250" data-end="1302">schedule tasks with delays or periodic execution</strong>.</li>
    <li><strong>Key methods</strong>
        <ul>
            <li><code data-start="861" data-end="871">schedule()</code> ‚Äì <strong>schedules a one-time task</strong> to run after a specified delay</li>
            <li><code data-start="861" data-end="871">scheduleAtFixedRate(timeout, unit)</code> ‚Äì <strong>schedules a task to run repeatedly</strong> at a <strong data-start="947" data-end="961">fixed rate</strong>, regardless of how long the task takes</li>
            <li><code data-start="861" data-end="871">scheduleWithFixedDelay()</code> ‚Äì schedules a task to run repeatedly with a <strong data-start="1454" data-end="1469">fixed delay</strong> <strong data-start="1470" data-end="1506">after the previous task finishes</strong></li>
        </ul>
    </li>
    <li><strong data-start="798" data-end="810">Example:</strong></li>
</ul>
<div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
scheduler.schedule(() -&gt; System.out.println("Delayed task"), 1, TimeUnit.SECONDS);
scheduler.scheduleAtFixedRate(() -&gt; System.out.println("Fixed-Rate scheduled task"), 1, 1, TimeUnit.SECONDS);
scheduler.scheduleWithFixedDelay(() -&gt; System.out.println("Fixed-Delay scheduled task"), 1, 2, TimeUnit.SECONDS);

Thread.sleep(3000); // Main thread sleeps for 3 seconds, so that scheduler can run a few iterations

scheduler.shutdown();
boolean terminated = scheduler.awaitTermination(5, TimeUnit.SECONDS);
System.out.println("Scheduler terminated: " + terminated);

// Delayed task
// Fixed-Rate scheduled task
// Fixed-Delay scheduled task
// Fixed-Rate scheduled task
// Fixed-Rate scheduled task
// Fixed-Delay scheduled task
// Scheduler terminated: true</code></pre>

    <hr class="" data-start="733" data-end="736" />

</div>
<h4 data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ </strong>ThreadPoolExecutor</h4>
<ul>
    <li><strong data-start="165" data-end="188">Core implementation</strong> of Java's thread pooling mechanism.</li>
    <li>Offers <strong data-start="333" data-end="357">fine-grained control</strong> over threading behaviour, i.e., number of threads, task queue, thread life cycle, task rejection policy, etc.</li>
    <li><strong>Key Parameters</strong>
        <ul>
            <li><code data-start="1821" data-end="1835">corePoolSize</code> ‚Äì minimum threads to keep alive, even if idle</li>
            <li><code data-start="1821" data-end="1835">maximumPoolSize</code> ‚Äì maximum number of threads allowed</li>
            <li><code data-start="1821" data-end="1835">keepAliveTime</code> ‚Äì maximum time that excess idle threads will wait before being killed</li>
            <li><code data-start="1821" data-end="1835">unit</code> ‚Äì time unit for <code data-start="961" data-end="976">keepAliveTime</code></li>
            <li><code data-start="1821" data-end="1835">workQueue</code> ‚Äì queue for holding pending tasks</li>
            <li><code data-start="1821" data-end="1835">threadFactory</code> ‚Äì custom thread creation</li>
            <li><code data-start="1821" data-end="1835">handler</code> ‚Äì policy to use for rejected tasks</li>
        </ul>
    </li>
    <li><strong>Queue Strategies</strong>
        <ul>
            <li><code data-start="1821" data-end="1835">ArrayBlockingQueue</code> ‚Äì bounded queue</li>
            <li><code data-start="1821" data-end="1835">LinkedBlockingQueue</code> ‚Äì unbounded queue</li>
            <li><code data-start="1821" data-end="1835">PriorityBlockingQueue</code> ‚Äì priority-based ordering</li>
        </ul>
    </li>
    <li><strong>Rejection Policies</strong>
        <ul>
            <li><code data-start="1821" data-end="1835">AbortPolicy</code> (default) ‚Äì throws¬†<code>RejectedExecutionException</code></li>
            <li><code data-start="1821" data-end="1835">CallerRunsPolicy</code> ‚Äì executes task in caller's thread</li>
            <li><code data-start="1821" data-end="1835">DiscardPolicy</code> ‚Äì silently discards task</li>
            <li><code data-start="1821" data-end="1835">DiscardOldestPolicy</code> ‚Äì discards¬†oldest queued task</li>
        </ul>
    </li>
    <li><strong>Task Execution Flow</strong>
        <ul>
            <li>New tasks go to¬†<strong>core threads</strong>¬†if available</li>
            <li>If core threads busy, tasks go to¬†<strong>work queue</strong></li>
            <li>If queue full, new threads created up to¬†<code>maximumPoolSize</code></li>
            <li>If max threads reached,¬†<strong>rejection policy</strong>¬†triggers</li>
        </ul>
    </li>
    <li><strong data-start="798" data-end="810">Example:</strong></li>
</ul>
<div>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">ThreadPoolExecutor tpe = new ThreadPoolExecutor(
        2,  // Core threads
        3, // Max threads
        60, // Keep-alive
        TimeUnit.SECONDS,
        new ArrayBlockingQueue&lt;&gt;(5),  // Bounded queue
        Executors.defaultThreadFactory(),
        new ThreadPoolExecutor.CallerRunsPolicy()   // Fallback
);

// Submit tasks
for (int i = 0; i &lt; 10; i++) {
    tpe.execute(() -&gt; {
        System.out.printf("Task running in %s [Active threads: %d, Queue size: %d, Completed tasks: %d]%n",
                Thread.currentThread().getName(), tpe.getActiveCount(), tpe.getQueue().size(), tpe.getCompletedTaskCount());
    });
}

tpe.shutdown(); // Graceful shutdown

// Task running in pool-4-thread-1 [Active threads: 2, Queue size: 0, Completed tasks: 0]
// Task running in pool-4-thread-2 [Active threads: 2, Queue size: 5, Completed tasks: 0]
// Task running in main [Active threads: 3, Queue size: 5, Completed tasks: 0]
// Task running in pool-4-thread-3 [Active threads: 3, Queue size: 5, Completed tasks: 0]
// Task running in pool-4-thread-3 [Active threads: 3, Queue size: 3, Completed tasks: 3]
// Task running in pool-4-thread-3 [Active threads: 3, Queue size: 2, Completed tasks: 4]
// Task running in pool-4-thread-1 [Active threads: 3, Queue size: 4, Completed tasks: 1]
// Task running in pool-4-thread-2 [Active threads: 3, Queue size: 3, Completed tasks: 2]
// Task running in pool-4-thread-3 [Active threads: 3, Queue size: 1, Completed tasks: 5]
// Task running in pool-4-thread-1 [Active threads: 3, Queue size: 0, Completed tasks: 6]</code></pre>
    </div>
</div>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ CompletableFuture</strong></h3>
<ul>
    <li>Provides a powerful way to write <strong data-start="2661" data-end="2677">non-blocking</strong>, <strong data-start="2679" data-end="2695">asynchronous</strong>, and <strong data-start="2701" data-end="2715">composable</strong> code that's easier to read and maintain than raw threads or callbacks.</li>
    <li>It helps to run code in the <strong data-start="297" data-end="311">background</strong>, chain dependent tasks (one after another), run <strong data-start="352" data-end="382">multiple tasks in parallel</strong>, combine multiple async results, and handle<strong data-start="392" data-end="415">¬†failure</strong> scenarios.</li>
    <li><strong data-start="798" data-end="810">Key Methods</strong>
        <ul>
            <li><code data-start="861" data-end="871">runAsync()</code> ‚Äì<span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> starts a task that returns void</span></li>
            <li><code data-start="861" data-end="871">supplyAsync()</code> ‚Äì<span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> starts a task that returns a result</span></li>
            <li><code data-start="861" data-end="871">thenAccept()</code> ‚Äì<span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> consumes the result</span></li>
            <li><code data-start="861" data-end="871">thenApply()</code> ‚Äì<span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> transforms the result</span></li>
            <li><code data-start="861" data-end="871">thenRun()</code> ‚Äì<span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> runs next task without result</span></li>
            <li><code data-start="861" data-end="871">thenCompose()</code> ‚Äì<span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> triggers another async task, based on the previous result</span></li>
            <li><code data-start="861" data-end="871">thenCombine()</code> ‚Äì<span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> combine results from two futures</span></li>
            <li><code data-start="861" data-end="871">exceptionally()</code> ‚Äì<span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> handle exceptions gracefully</span></li>
        </ul>
    </li>
    <li><strong data-start="798" data-end="810">Example:</strong></li>
</ul>
<div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">// run async task (no return value)
CompletableFuture future1 = CompletableFuture.runAsync(() -&gt; {
    System.out.println("Running in background");
}); // Running in background

// supply async task (returns value)
CompletableFuture future2 = CompletableFuture.supplyAsync(() -&gt; {
    return "Hello World";
});

// blocking get
String result = future2.get();

// non-blocking callback
future2.thenAccept(result1 -&gt; System.out.println("Result: " + result1));    // Result: Hello World

// thenApply() - transform result
CompletableFuture future3 = CompletableFuture.supplyAsync(() -&gt; "Hello")
        .thenApply(s -&gt; s + " World")
        .thenApply(String::toUpperCase);

future3.thenAccept(System.out::println);    // HELLO WORLD

// thenCompose() - chain dependent futures
CompletableFuture getUser = CompletableFuture.supplyAsync(() -&gt; "user123");
CompletableFuture getOrder = getUser.thenCompose(user -&gt;
        CompletableFuture.supplyAsync(() -&gt; "Order for " + user)
);

getOrder.thenAccept(System.out::println);   // Order for user123

// thenCombine() - merge two futures
CompletableFuture hello = CompletableFuture.supplyAsync(() -&gt; "Hello");
CompletableFuture world = CompletableFuture.supplyAsync(() -&gt; "World");

hello.thenCombine(world, (h, w) -&gt; h + " " + w)
        .thenAccept(System.out::println); // "Hello World"

// allOf() - wait for all futures
CompletableFuture all = CompletableFuture.allOf(
        CompletableFuture.supplyAsync(() -&gt; "Task1"),
        CompletableFuture.supplyAsync(() -&gt; "Task2")
);

all.thenRun(() -&gt; System.out.println("All tasks completed"));   // All tasks completed

// exceptionally() - fallback Value
CompletableFuture.supplyAsync(() -&gt; {
            if (Math.random() &gt; 0.5) throw new RuntimeException("Error!");
            return "Success";
        })
        .exceptionally(ex -&gt; "Fallback: " + ex.getMessage())
        .thenAccept(System.out::println);   // Fallback: java.lang.RuntimeException: Error!

// handle() - success/failure in one method
CompletableFuture.supplyAsync(() -&gt; "Process data")
        .handle((result2, ex) -&gt; {
            if (ex != null) return "Error occurred";
            return result2.toUpperCase();
        });</code></pre>

    <hr class="" data-start="733" data-end="736" />

    <h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ ThreadLocal Variables</strong></h3>
    <ul>
        <li>Allows us to create <strong data-start="180" data-end="220">variables that are local to a thread</strong>.</li>
        <li>Each thread has its <strong data-start="245" data-end="266">own isolated copy</strong> of the variable and other threads <strong data-start="300" data-end="327">cannot access or modify</strong> that variable.</li>
        <li><strong data-start="798" data-end="810">Example:</strong></li>
    </ul>
    <div>
        <div>
            <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">// Create a ThreadLocal holder class
public class RequestContext {
    private static final ThreadLocal&lt;String&gt; transactionId = new ThreadLocal&lt;&gt;();

    public static void setTransactionId(String id) {
        transactionId.set(id);
    }

    public static String getTransactionId() {
        return transactionId.get();
    }

    public static void clear() {
        transactionId.remove(); // Important to prevent memory leaks
    }
}

// Set the transaction ID at the beginning of the request
@Component
public class TransactionIdFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {

        try {
            // Generate or extract transaction ID (e.g., from headers)
            String txnId = UUID.randomUUID().toString();
            RequestContext.setTransactionId(txnId);

            // Continue the chain
            chain.doFilter(request, response);

        } finally {
            // Clean up
            RequestContext.clear();
        }
    }
}</code></pre>
                <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">/* *** *** *** *** *** test code *** *** *** *** *** */
// In any service or DAO class, you can access the transaction ID without passing it as a parameter
String txnId = RequestContext.getTransactionId();
System.out.println("Processing order for Transaction ID: " + txnId);</code></pre>
                </div>
            </div>
        </div>
    </div>
    <ul>
        <li><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">Use Case:¬†</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">Storing </span><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="643" data-end="664">user session data</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> per thread, </span><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="757" data-end="781">database connections</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> or request-scoped objects in web servers.</span></li>
        <li><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">Note: </strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">If you're using </span><code style="font-size: inherit;" data-start="1614" data-end="1627">ThreadLocal</code><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> in environments like </span><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="1649" data-end="1665">thread pools</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">, remember to </span><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="1679" data-end="1708">remove the value manually</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> to prevent </span><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="1720" data-end="1736">memory leaks</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">.</span></li>
    </ul>

    <hr class="" data-start="733" data-end="736" />

    <h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ CountDownLatch</strong></h3>
    <ul>
        <li>Allows <strong data-start="199" data-end="230">one or more threads to wait</strong> until a set of operations being performed by other threads <strong data-start="290" data-end="303">completes</strong>.</li>
        <li><strong>Key Characteristics</strong>
            <ul>
                <li><strong>Initialized with a count</strong>¬†(number of events to wait for)</li>
                <li><strong>Threads call¬†<code>countDown()</code></strong>¬†when an event completes</li>
                <li><strong>Awaiting threads block</strong>¬†until count reaches zero</li>
                <li><strong>One-time use</strong> (cannot be reset)</li>
            </ul>
        </li>
        <li><strong data-start="798" data-end="810">Example:</strong></li>
    </ul>
    <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">static class Service implements Runnable {
    private final String name;
    private final int initTime;
    private final CountDownLatch latch;

    public Service(String name, int initTime, CountDownLatch latch) {
        this.name = name;
        this.initTime = initTime;
        this.latch = latch;
    }

    @Override
    public void run() {
        try {
            Thread.sleep(initTime);
            System.out.println(name + " service initialized");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            latch.countDown(); // Decrement count
        }
    }
}</code></pre>
        <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">/* *** *** *** *** *** test code *** *** *** *** *** */
CountDownLatch latch = new CountDownLatch(3);   // Initialize latch with count=3 (for 3 services)

// Start service initialization threads
new Thread(new Service("Auth", 1000, latch)).start();
new Thread(new Service("Cache", 1500, latch)).start();
new Thread(new Service("Database", 2000, latch)).start();

// Main thread waits for all services
System.out.println("Waiting for services to initialize...");
latch.await();

// Proceed when count reaches 0
System.out.println("All services are ready! Starting application...");

// Waiting for services to initialize...
// Auth service initialized
// Cache service initialized
// Database service initialized
// All services are ready! Starting application...</code></pre>
        </div>
    </div>
    <ul>
        <li><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">Use Case: </strong>Multi-stage dependency (e.g., load config ‚Üí start server), <strong>Parallel Processing</strong> - Wait for multiple threads to complete before proceeding<span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">.</span></li>
    </ul>
    <div>
        <div></div>
    </div>

    <hr class="" data-start="733" data-end="736" />

    <h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ ConcurrentHashMap</strong></h3>
    <ul>
        <li>A<strong data-start="168" data-end="183"> thread-safe</strong> and <strong data-start="188" data-end="208">high-performance</strong> implementation of <code data-start="227" data-end="232">Map</code> that allows <strong data-start="712" data-end="732">concurrent reads</strong> and <strong data-start="737" data-end="773">fine-grained synchronized writes</strong>.</li>
        <li>Achieves <strong>High concurrency</strong> through segment-level locking (Java 7) or CAS (Compare-And-Swap) operations (Java 8+).</li>
        <li><strong>Key Features</strong>
            <ul>
                <li>Allows <strong data-start="894" data-end="914">concurrent reads</strong> (no lock at all)</li>
                <li>Allows <strong data-start="941" data-end="967">safe concurrent writes</strong> (locks only buckets, not whole map)</li>
                <li><strong>Weakly consistent</strong> iterators (don't throw ConcurrentModificationException)</li>
                <li>For compound operations (like <code data-start="1320" data-end="1333">putIfAbsent</code>, <code data-start="1335" data-end="1344">compute</code>, <code data-start="1346" data-end="1353">merge</code>), internal atomic mechanisms are used</li>
            </ul>
        </li>
        <li><strong data-start="798" data-end="810">Example:</strong></li>
    </ul>
    <div>
        <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">ConcurrentHashMap&lt;String, Integer&gt; counter1 = new ConcurrentHashMap&lt;&gt;();

Runnable task1 = () -&gt; {
    for (int i = 0; i &lt; 1000; i++) {
        counter1.merge("count", 1, (oldVal, newVal) -&gt; oldVal + newVal);
    }
};

Thread t6 = new Thread(task1);
Thread t7 = new Thread(task1);

t6.start(); t7.start();
t6.join(); t7.join();

System.out.println("Thread-safe total count: " + counter1.get("count"));

// Thread-safe total count: 2000</code></pre>
        </div>
    </div>

    <hr class="" data-start="733" data-end="736" />

    <h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ <a href="https://en.wikipedia.org/wiki/Virtual_thread">Virtual Threads</a></strong></h3>
    <ul>
        <li>Lightweight threads <strong data-start="229" data-end="274">managed by the Java Virtual Machine (JVM)</strong>, not the operating system.</li>
        <li>Introduced in <strong data-start="96" data-end="116">Java 21 (stable)</strong> as part of <a href="https://wiki.openjdk.org/display/loom/Main"><strong data-start="128" data-end="144">Project Loom</strong></a>.</li>
        <li>Ideal for highly concurrent applications ‚Äî like web servers, APIs, and reactive pipelines.</li>
        <li><strong>Execution Lifecycle</strong>
            <ul>
                <li><strong>Mount Phase</strong>
                    <ul>
                        <li>Virtual thread is scheduled on a carrier thread (from ForkJoinPool)</li>
                        <li>Stack frames live in OS thread stack</li>
                    </ul>
                </li>
                <li><strong>Yield Phase</strong> (on blocking ops ‚Äî IO/sleep)
                    <ul>
                        <li>Stack copied to heap as continuation</li>
                        <li>Carrier thread freed for other Virtual threads</li>
                    </ul>
                </li>
                <li><strong>Resume Phase</strong>
                    <ul>
                        <li>Continuation restored to a carrier thread</li>
                        <li>Execution continues exactly where it left off</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><strong>Key Features</strong>
            <ul>
                <li>Fully integrated into the Java concurrency model (<code data-start="633" data-end="641">Thread</code>, <code data-start="643" data-end="660">ExecutorService</code>, etc.)</li>
                <li>Each virtual thread maps to a <strong data-start="523" data-end="553">carrier thread (OS thread)</strong> only when actively running</li>
                <li><strong>No pooling needed</strong> (cheap to create/discard per-task)</li>
                <li>Thousands or millions of threads without exhausting OS resources</li>
            </ul>
        </li>
        <li><strong data-start="798" data-end="810">Example:</strong></li>
    </ul>
    <div>
        <div>
<pre class="language-java line-numbers lazy-load" data-loaded="false"><code class="language-java">// Create virtual thread (Option 1: Thread.startVirtualThread)
Thread vThread = Thread.startVirtualThread(() -&gt; {
    System.out.println(Thread.currentThread() + ": Hello from virtual thread!");
});

// Wait for completion
try { vThread.join(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }

// VirtualThread[#58]/runnable@ForkJoinPool-1-worker-1: Hello from virtual thread!

// Create virtual thread (Option 2: Builder pattern)
Thread.ofVirtual()
        .name("my-virtual-thread")
        .start(() -&gt; {
            System.out.println(Thread.currentThread() + ": Virtual thread with custom name");
        });

// VirtualThread[#60,my-virtual-thread]/runnable@ForkJoinPool-1-worker-2: Virtual thread with custom name

// Create virtual threads with ExecutorService
try (ExecutorService executor2 = Executors.newVirtualThreadPerTaskExecutor()) {
    for (int i = 0; i &lt; 5; i++) {
        int taskId = i;
        executor2.submit(() -&gt; {
            System.out.println(Thread.currentThread() + ": Executor task " + taskId + " running");
            Thread.sleep(500);  // sleep is non-blocking in virtual threads
            return null;
        });
    }
} // Auto-close waits for all tasks

// VirtualThread[#63]/runnable@ForkJoinPool-1-worker-2: Executor task 0 running
// VirtualThread[#67]/runnable@ForkJoinPool-1-worker-5: Executor task 4 running
// VirtualThread[#65]/runnable@ForkJoinPool-1-worker-3: Executor task 2 running
// VirtualThread[#64]/runnable@ForkJoinPool-1-worker-1: Executor task 1 running
// VirtualThread[#66]/runnable@ForkJoinPool-1-worker-4: Executor task 3 running

// A Million Threads (Impossible with Platform Threads)
for (int i = 0; i &lt; 1_000_000; i++) {
    int taskId = i;
    Thread.startVirtualThread(() -&gt; {
        System.out.println(Thread.currentThread() + ": Task " + taskId + " running");
        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
    });
}

// VirtualThread[#1000079]/runnable@ForkJoinPool-1-worker-4: Task 999997 running
// VirtualThread[#1000080]/runnable@ForkJoinPool-1-worker-4: Task 999998 running
// VirtualThread[#1000081]/runnable@ForkJoinPool-1-worker-4: Task 999999 running
// VirtualThread[#997930]/runnable@ForkJoinPool-1-worker-8: Task 997848 running
// VirtualThread[#997919]/runnable@ForkJoinPool-1-worker-1: Task 997837 running
// VirtualThread[#1000002]/runnable@ForkJoinPool-1-worker-7: Task 999920 running</code></pre>
        </div>
    </div>
    <ul>
        <li><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">Use Case: </strong>Web servers (e.g., handle each request in a virtual thread), File and network I/O, Replacing <code data-start="2420" data-end="2437">ExecutorService</code> or <code data-start="3854" data-end="3873">CompletableFuture</code> chains with simpler thread-per-task model<span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">.</span></li>
        <li><strong><strong><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">Note</strong>: </strong></strong>In Java virtual threads, <code style="font-size: inherit;" data-start="273" data-end="289">Thread.sleep()</code><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> is implemented as a </span><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="310" data-end="336">non-blocking operation</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">, meaning it </span><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="349" data-end="406">does not block the underlying operating system thread</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> (also known as the </span><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="426" data-end="444">carrier thread</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">). </span>Instead, the <strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="468" data-end="502">JVM‚Äôs virtual thread scheduler</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> temporarily suspends the virtual thread, freeing up the carrier thread to execute other virtual threads.</span></li>
    </ul>

    <hr class="" data-start="733" data-end="736" />

</div>