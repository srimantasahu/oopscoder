<p class="" data-start="107" data-end="384">Concurrency is a <strong data-start="124" data-end="167">core aspect of modern Java applications</strong>, enabling them to efficiently handle multiple tasks in parallel. Whether you're building <strong data-start="257" data-end="336">high-performance systems, real-time applications, or scalable microservices</strong>, understanding Java concurrency is essential.</p>
<p class="" data-start="386" data-end="910">In this guide, we‚Äôll explore <strong data-start="415" data-end="452">Java‚Äôs concurrency model in depth</strong>, covering <strong data-start="463" data-end="535">threads, synchronization, executors, and advanced locking mechanisms</strong>. You‚Äôll learn:¬†<br data-start="550" data-end="553" />‚úîÔ∏è How <strong data-start="560" data-end="571">threads</strong> work and how to create them efficiently¬†<br data-start="611" data-end="614" />‚úîÔ∏è The role of <strong data-start="629" data-end="648">synchronization</strong> and how to avoid race conditions¬†<br data-start="681" data-end="684" />‚úîÔ∏è How <strong data-start="691" data-end="720">Executors and ThreadPools</strong> improve performance¬†<br data-start="740" data-end="743" />‚úîÔ∏è Advanced concepts like <strong data-start="769" data-end="821">ReentrantLocks, Semaphores, and Atomic variables¬†</strong><br data-start="821" data-end="824" />‚úîÔ∏è Best practices for writing <strong data-start="854" data-end="908">deadlock-free and scalable concurrent applications¬†</strong></p>
<p class="" data-start="912" data-end="1107">With <strong data-start="917" data-end="947">step-by-step code examples</strong> and real-world use cases, this guide will help you <strong data-start="999" data-end="1026">master Java concurrency</strong> and write robust, multi-threaded applications with confidence. üöÄ Let‚Äôs dive in!</p>


<hr class="" data-start="771" data-end="774" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ</strong><strong data-start="267" data-end="284"> Thread vs Runnable</strong></h3>
<ul>
    <li class="p1">A <b>thread is a single sequential flow of control</b> and takes an independent path of execution within a program.</li>
    <li class="p1">Threads are basically <b>used to do background processing and parallel processing when the order of execution doesn't matter</b>.</li>
    <li data-start="39" data-end="90">In Java, we can create threads in two main ways:</li>
</ul>
<ol>
    <li style="list-style-type: none;">
        <ol>
            <li data-start="94" data-end="128"><strong data-start="94" data-end="126">Extending the <code data-start="110" data-end="118">Thread</code> class</strong>
                <ul>
                    <li data-start="94" data-end="128">The class directly inherits from <code data-start="435" data-end="443">Thread</code> and overrides the <code data-start="462" data-end="469">run()</code> method.</li>
                    <li data-start="94" data-end="128">The <code data-start="484" data-end="493">start()</code> method is used to begin execution in a separate thread.</li>
                </ul>
            </li>
            <li data-start="132" data-end="175"><strong data-start="132" data-end="173">Implementing the <code data-start="151" data-end="161">Runnable</code> interface</strong>
                <ul>
                    <li data-start="132" data-end="175">The class implements <code data-start="1269" data-end="1279">Runnable</code> and overrides the <code data-start="1298" data-end="1305">run()</code> method.</li>
                    <li data-start="132" data-end="175">The <code data-start="1320" data-end="1328">Thread</code> class is used to execute the <code data-start="1358" data-end="1368">Runnable</code> instance.</li>
                </ul>
            </li>
        </ol>
    </li>
</ol>
<ul>
    <li><strong data-start="798" data-end="810">Example</strong>:</li>
</ul>
<div>
<pre>static class MyThread extends Thread {
    public void run() {
        System.out.println("MyThread's thread: " + Thread.currentThread().getName());
    }
}

static class MyRunnable implements Runnable {
    public void run() {
        System.out.println("MyRunnable's thread: " + Thread.currentThread().getName());
    }
}</pre>
    <div>
<pre>// test code
System.out.println("Current thread: " + Thread.currentThread().getName());
// Current thread: main

MyThread t1 = new MyThread();
t1.start(); // Starts a new thread
// MyThread's thread: Thread-0

Thread t2 = new Thread(new MyRunnable());
t2.start(); // Starts a new thread
// MyRunnable's thread: Thread-1</pre>
    </div>
</div>
<ul>
    <li>Using <code data-start="512" data-end="522">Runnable</code> is generally preferred as it promotes better design by <strong data-start="578" data-end="633">separating the task from the thread execution logic</strong>, making the code more flexible (e.g., allows extending other classes) and maintainable.</li>
</ul>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Synchronized</strong></h3>
<ul>
    <li data-start="62" data-end="210">The <code data-start="66" data-end="80">synchronized</code> keyword in Java is used to <strong data-start="108" data-end="135">prevent race conditions</strong> when multiple threads try to access shared resources <strong data-start="189" data-end="209">at the same time</strong>. It ensures that <strong data-start="228" data-end="247">only one thread</strong> can execute a block of code or method <strong data-start="286" data-end="299">at a time</strong>, keeping data <strong data-start="314" data-end="337">safe and consistent</strong> in multithreaded environments.</li>
    <li data-start="62" data-end="210">Two Ways to Use <code data-start="586" data-end="600">synchronized</code>:
        <ol>
            <li data-start="62" data-end="210"><strong>Synchronized Method</strong>
                <ul>
                    <li data-start="62" data-end="210">Locks on the object (<code data-start="657" data-end="663">this</code>) for instance methods or on the class for static methods.</li>
                </ul>
            </li>
            <li data-start="62" data-end="210"><strong>Synchronized Block</strong>
                <ul>
                    <li data-start="62" data-end="210">Allows us to synchronize <strong data-start="1057" data-end="1065">part</strong> of a method, giving more fine-grained control.</li>
                </ul>
            </li>
        </ol>
    </li>
    <li><strong data-start="798" data-end="810">Example</strong>:</li>
</ul>
<div>
    <div>
<pre>static class SharedResource {
    private final Object lock = new Object();
    private int count = 1;

    public synchronized void incrementUsingSynchronizedMethod() {
        for (int i = 1; i &lt;= 3; i++) {
            System.out.println("[Synchronized Method] " + Thread.currentThread().getName() + ": " + count++);
        }
    }

    public void incrementUsingSynchronizedBlock() {
        synchronized (this) {
            for (int i = 1; i &lt;= 3; i++) {
                System.out.println("[Synchronized Block] " + Thread.currentThread().getName() + ": " + count++);
            }
        }
    }

    public void incrementUsingSynchronizedLockObject() {
        synchronized (lock) {
            for (int i = 1; i &lt;= 3; i++) {
                System.out.println("[Synchronized Lock Object] " + Thread.currentThread().getName() + ": " + count++);
            }
        }
    }
}</pre>
    </div>
    <div>
<pre>// test code
SharedResource resource = new SharedResource();
new Thread(resource::incrementUsingSynchronizedMethod).start();
new Thread(resource::incrementUsingSynchronizedBlock).start();
new Thread(resource::incrementUsingSynchronizedLockObject).start();

// [Synchronized Method] Thread-2: 1
// [Synchronized Lock Object] Thread-4: 2
// [Synchronized Method] Thread-2: 3
// [Synchronized Lock Object] Thread-4: 4
// [Synchronized Method] Thread-2: 5
// [Synchronized Lock Object] Thread-4: 6
// [Synchronized Block] Thread-3: 7
// [Synchronized Block] Thread-3: 8
// [Synchronized Block] Thread-3: 9</pre>
    </div>
</div>
<ul>
    <li>¬†Note that Synchronized Method and Synchronized Block are using the same shared lock¬†(<code data-start="657" data-end="663">this</code>), so the second one (i.e., <code data-start="657" data-end="663">Thread-3</code>) starts after the first thread (i.e., <code data-start="657" data-end="663">Thread-2</code>) releases the lock.</li>
</ul>

<hr class="" data-start="771" data-end="774" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ</strong><strong data-start="267" data-end="284"> wait, notify, and join methods</strong></h3>
<ul>
    <li><strong><code>wait()</code></strong>: Releases the lock and makes the thread¬†<strong>wait</strong>¬†until another thread calls¬†<code>notify()</code>.</li>
    <li><strong><code>notify()</code></strong>: Wakes up¬†<strong>one</strong>¬†waiting thread (randomly chosen).</li>
    <li><strong><code>notifyAll()</code></strong>: Wakes up¬†<strong>all</strong>¬†waiting threads.</li>
    <li><strong><code>join()</code></strong>: <strong>Waits for a thread to complete</strong>¬†before proceeding.</li>
    <li><strong data-start="798" data-end="810">Example</strong>:</li>
</ul>
<div>
    <div>
<pre>static class SimpleProducerConsumer {
    private int data;
    private boolean ready = false;

    public synchronized void produce(int value) {
        System.out.println("Producer: Producing data = " + value);
        data = value;
        ready = true;
        notify(); // Notify the waiting consumer
        System.out.println("Producer: Data produced and notified.");
    }

    public synchronized int consume() throws InterruptedException {
        while (!ready) {
            System.out.println("Consumer: Waiting for data...");
            wait(); // Wait until data is produced
        }
        System.out.println("Consumer: Data received = " + data);
        return data;
    }
}</pre>
    </div>
    <div>
<pre>// test code
SimpleProducerConsumer simpleProducerConsumer = new SimpleProducerConsumer();

Thread producer = new Thread(() -&gt; {
    try {
        Thread.sleep(1000); // Simulate delay of 1000 ms
        simpleProducerConsumer.produce(19);
    } catch (InterruptedException e) { /* handle it */ }
});

Thread consumer = new Thread(() -&gt; {
    try {
        int received = simpleProducerConsumer.consume();
    } catch (InterruptedException e) { /* handle it */ }
});

producer.start(); // Starts Producer thread
consumer.start(); // Starts Consumer thread

// Use join() to wait for both threads to finish
producer.join(); // Main thread waits for producer to finish
consumer.join(); // Main thread waits for consumer to finish

System.out.println("Main thread: Producer and Consumer finished.");

// Consumer: Waiting for data...
// Producer: Producing data...
// Producer: Data produced and notified.
// Consumer: Data received = 19
// Main thread: Producer and Consumer finished.</pre>
    </div>
</div>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Thread Lifecycle</strong></h3>
<ul>
    <li data-start="579" data-end="613"><strong data-start="579" data-end="587">NEW</strong>: Thread is <strong>created but not started</strong>¬†(<code>start()</code>¬†not called yet).</li>
    <li data-start="619" data-end="664"><strong data-start="619" data-end="632">RUNNABLE</strong>: Thread is <strong>ready to run</strong>¬†(after calling¬†<code>start()</code>) but may not be executing yet (depends on the OS scheduler).</li>
    <li data-start="670" data-end="737"><strong data-start="670" data-end="690">BLOCKED</strong>: Thread is¬†<strong>waiting for a monitor lock</strong>¬†(e.g., trying to enter a¬†<code>synchronized</code>¬†block).</li>
    <li><strong data-start="670" data-end="690">WAITING</strong>: Thread¬†<strong>waits indefinitely</strong>¬†for another thread to notify it (via¬†<code>wait()</code>,¬†<code>join()</code>, or¬†<code>LockSupport.park()</code>).</li>
    <li data-start="743" data-end="798"><strong data-start="743" data-end="761">TIMED_WAITING</strong>: Thread¬†<strong>waits for a specified time</strong>¬†(via¬†<code>sleep(time)</code>,¬†<code>wait(timeout)</code>,¬†<code>join(timeout)</code>).</li>
    <li data-start="804" data-end="841"><strong data-start="804" data-end="819">TERMINATED</strong>: Thread¬†<strong>has finished execution</strong>¬†(<code>run()</code>¬†method completed).</li>
</ul>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Volatile</strong></h3>
<ul>
    <li data-start="176" data-end="229">In multithreaded programs, threads can <strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="419" data-end="438">cache variables</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> locally (in CPU registers or thread stacks) for performance.¬†</span></li>
    <li data-start="176" data-end="229">The <code data-start="180" data-end="190">volatile</code> keyword tells the <strong data-start="209" data-end="228">JVM and threads</strong>:
        <ul>
            <li>‚ÄúHey! This variable is shared between threads, so don‚Äôt cache it. Always read and write directly from main memory.‚Äù</li>
        </ul>
    </li>
    <li data-start="176" data-end="229">Without <code style="font-size: inherit;" data-start="509" data-end="519">volatile</code><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">, a thread might keep </span><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="541" data-end="566">reading a stale value</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> ‚Äî never seeing the latest value written by another thread.</span></li>
    <li><strong data-start="798" data-end="810">Example</strong>:</li>
</ul>
<div>
    <div>
<pre>static class Worker {
    private volatile boolean running = true;  // visible across threads

    public void run() {
        System.out.println(Thread.currentThread().getName() + ": started.");
        while (running) { /* simulate some work */ }
        // stops when running=false (reads from main memory)
        System.out.println(Thread.currentThread().getName() + ": stopped.");
    }

    public void stopRunning() {
        running = false;
    }
}</pre>
    </div>
    <div>
<pre>// test code
Worker worker = new Worker();
Thread t3 = new Thread(worker::run);
t3.start();

// let the thread t3 run for 2 seconds
Thread.sleep(2000);

System.out.println("Main thread: stopping worker...");
worker.stopRunning();

// wait for the worker to finish
t3.join();
System.out.println("Main thread: worker has stopped.");

// Thread-5: started.
// Main thread: stopping worker...
// Thread-5: stopped.
// Main thread: worker has stopped.</pre>
    </div>
</div>
<ul>
    <li><strong data-start="727" data-end="739">Use Case</strong>: One thread <strong data-start="2115" data-end="2125">writes</strong>, and many threads <strong data-start="2144" data-end="2152">read</strong>. We need to communicate <strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="2180" data-end="2189">flags</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">, like: </span><code data-start="2201" data-end="2212">isRunning</code>,¬†<code data-start="2217" data-end="2229">isShutdown</code>,¬†<code data-start="2234" data-end="2246">shouldStop</code>.</li>
</ul>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Atomic Data Types</strong></h3>
<ul>
    <li class="p1">Provide <strong data-start="193" data-end="206">lock-free</strong>, <strong data-start="208" data-end="223">thread-safe</strong> operations on single variables.</li>
    <li>Use <strong data-start="355" data-end="388">CPU-level atomic instructions</strong>, like Compare-And-Swap (CAS), to ensure thread safety without <code data-start="451" data-end="465">synchronized</code>.</li>
    <li class="p1">Common types: <code data-start="273" data-end="288">AtomicInteger</code>,¬†<code data-start="291" data-end="303">AtomicLong</code>,¬†<code data-start="306" data-end="321">AtomicBoolean</code>,¬†<code data-start="324" data-end="344">AtomicReference&lt;T&gt;</code></li>
    <li class="p1">Supports atomic operations like <code data-start="95" data-end="114">incrementAndGet()</code> ‚Äì Atomic counter increment, <code data-start="148" data-end="181">compareAndSet(expected, update)</code> ‚Äì Conditional update (CAS), etc.</li>
    <li><strong data-start="798" data-end="810">Example</strong>:</li>
</ul>
<div>
    <div>
<pre>AtomicInteger counter = new AtomicInteger(0);
AtomicBoolean printed = new AtomicBoolean(false);

Runnable task = () -&gt; {
    for (int i = 0; i &lt; 2; i++) {
        int current = counter.incrementAndGet();
        System.out.println(Thread.currentThread().getName() + ": Count = " + current);

        // Only one thread prints this when count reaches 1
        if (current &gt;= 1 &amp;&amp; printed.compareAndSet(false, true))
            System.out.println(Thread.currentThread().getName() + ": Count reached 1! (printed only once)");

        // Simulate delay
        try { Thread.sleep(100); } catch (InterruptedException e) { /* handle it */ }
    }
};

Thread t4 = new Thread(task, "Thread-1");
Thread t5 = new Thread(task, "Thread-2");

t4.start(); t5.start();
t4.join(); t5.join();

System.out.println("Main thread: Final Count = " + counter.get());

// Thread-2: Count = 2
// Thread-1: Count = 1
// Thread-2: Count reached 1! (printed only once)
// Thread-1: Count = 3
// Thread-2: Count = 4
// Main thread: Final Count = 4</pre>
    </div>
</div>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ ReentrantLock</strong></h3>
<ul>
    <li><strong data-start="318" data-end="331">Reentrant</strong> means - the same thread can acquire the same lock multiple times without getting blocked or causing a deadlock.</li>
    <li>
        <div>Provides <strong data-start="244" data-end="264">explicit locking</strong> with more features than the <code data-start="293" data-end="307">synchronized</code> keyword.</div></li>
    <li>Key Features
        <ul>
            <li><strong>Try-lock</strong> ‚Äì Attempt to acquire lock without blocking</li>
            <li><strong>Fairness policy</strong> ‚Äì Prevents thread starvation</li>
            <li><strong>Condition support</strong> ‚Äì For complex wait/notify scenarios</li>
        </ul>
    </li>
    <li><strong data-start="798" data-end="810">Example</strong>:</li>
</ul>
<div>
    <div>
        <div>
<pre>static class SimplePrinterQueue {

    private final ReentrantLock lock = new ReentrantLock(true); // fair lock
    private final Condition colorQueue = lock.newCondition();
    private final Condition bwQueue = lock.newCondition();
    private boolean printerBusy = false;

    public void printJob(String jobType) {
        boolean acquired = false;
        try {
            // Try to acquire lock with timeout
            acquired = lock.tryLock(1, TimeUnit.SECONDS);
            if (!acquired) {
                System.out.println(Thread.currentThread().getName() + ": Could not acquire lock. Skipping " + jobType + " job.");
                return;
            }

            Condition currentCondition = jobType.equals("color") ? colorQueue : bwQueue;

            // Wait if printer is busy
            while (printerBusy) {
                System.out.println(Thread.currentThread().getName() + ": Waiting in " + jobType + " queue.");
                currentCondition.await(); // wait until printer is busy
            }

            // Proceed to print
            printerBusy = true;
            System.out.println(Thread.currentThread().getName() + ": Printing a " + jobType + " job...");
            Thread.sleep(500); // simulate print time

            printerBusy = false;
            System.out.println(Thread.currentThread().getName() + ": Finished printing.");

            // Notify all waiting threads
            colorQueue.signal();
            bwQueue.signal();

        } catch (InterruptedException e) {
            // handle it
        } finally {
            if (acquired) {
                lock.unlock();
            }
        }
    }
}</pre>
            <div>
<pre>// test code
SimplePrinterQueue printer = new SimplePrinterQueue();

Runnable colorTask = () -&gt; printer.printJob("color");
Runnable bwTask = () -&gt; printer.printJob("bw");

for (int i = 0; i &lt; 2; i++) {
    new Thread(colorTask, "ColorThread-" + i).start();
    new Thread(bwTask, "BWThread-" + i).start();
}

// ColorThread-0: Printing a color job...
// ColorThread-0: Finished printing.
// BWThread-0: Printing a bw job...
// BWThread-1: Could not acquire lock. Skipping bw job.
// ColorThread-1: Could not acquire lock. Skipping color job.
// BWThread-0: Finished printing.</pre>
            </div>
        </div>
    </div>
    <div>
        <ul>
            <li><strong>Best Practices</strong>:
                <ul>
                    <li>Use try-lock to avoid deadlocks.</li>
                    <li>Always release lock in¬†<code>finally</code> block.</li>
                    <li>Consider fairness only if thread starvation is a concern.</li>
                </ul>
            </li>
        </ul>
    </div>
</div>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ ConcurrentHashMap</strong></h3>
<ul>
    <li>A<strong data-start="168" data-end="183"> thread-safe</strong> and <strong data-start="188" data-end="208">high-performance</strong> implementation of <code data-start="227" data-end="232">Map</code> that allows <strong data-start="712" data-end="732">concurrent reads</strong> and <strong data-start="737" data-end="773">fine-grained synchronized writes</strong>.</li>
    <li>Achieves <strong>High concurrency</strong> through segment-level locking (Java 7) or CAS (Compare-And-Swap) operations (Java 8+).</li>
    <li><strong>Key Features</strong>
        <ul>
            <li>Allows <strong data-start="894" data-end="914">concurrent reads</strong> (no lock at all)</li>
            <li>Allows <strong data-start="941" data-end="967">safe concurrent writes</strong> (locks only buckets, not whole map)</li>
            <li><strong>Weakly consistent</strong> iterators (don't throw ConcurrentModificationException)</li>
            <li>For compound operations (like <code data-start="1320" data-end="1333">putIfAbsent</code>, <code data-start="1335" data-end="1344">compute</code>, <code data-start="1346" data-end="1353">merge</code>), internal atomic mechanisms are used</li>
        </ul>
    </li>
    <li><strong data-start="798" data-end="810">Example</strong>:</li>
</ul>
<div>
    <div>
<pre>ConcurrentHashMap&lt;String, Integer&gt; counter1 = new ConcurrentHashMap&lt;&gt;();

Runnable task1 = () -&gt; {
    for (int i = 0; i &lt; 1000; i++) {
        counter1.merge("count", 1, (oldVal, newVal) -&gt; oldVal + newVal);
    }
};

Thread t6 = new Thread(task1);
Thread t7 = new Thread(task1);

t6.start(); t7.start();
t6.join(); t7.join();

System.out.println("Thread-safe total count: " + counter1.get("count"));

// Thread-safe total count: 2000</pre>
    </div>
</div>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Fork and Join Framework</strong></h3>
<ul>
    <li>Designed to <strong data-start="92" data-end="119">leverage multiple cores</strong> efficiently, especially for <strong data-start="148" data-end="186">parallel, divide-and-conquer tasks</strong>.</li>
    <li>Supports <strong data-start="2761" data-end="2778">work-stealing</strong> (idle threads "steal" tasks from busy ones) to optimize multi-core processor utilization.</li>
    <li><strong>Key Classes</strong>
        <ul>
            <li><strong><code>ForkJoinPool</code></strong> ‚Äì A special thread pool for running <code>ForkJoinTask</code>s</li>
            <li><strong><code>RecursiveTask&lt;V&gt;</code></strong> ‚Äì Use for task that <strong data-start="807" data-end="827">returns a result</strong></li>
            <li><strong><code>RecursiveAction</code></strong> ‚Äì Use for task that <strong data-start="871" data-end="899">does not return a result</strong></li>
        </ul>
    </li>
    <li><strong data-start="798" data-end="810">Example</strong>:</li>
</ul>
<div>
<pre>static class SumTask extends RecursiveTask&lt;Long&gt; {
    private static final int THRESHOLD = 3;
    private final int[] arr;
    private final int start, end;

    public SumTask(int[] arr, int start, int end) {
        this.arr = arr;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if (end - start &lt;= THRESHOLD) {
            // Base case: sum directly
            long sum = 0;
            for (int i = start; i &lt; end; i++) sum += arr[i];
            return sum;
        } else {
            // Fork
            int mid = (start + end) / 2;
            SumTask left = new SumTask(arr, start, mid);
            SumTask right = new SumTask(arr, mid, end);

            left.fork();    // run left asynchronously
            long rightResult = right.compute(); // compute right directly
            long leftResult = left.join();  // wait for left

            return leftResult + rightResult;
        }
    }
}</pre>
    <div>
<pre>// test code
int[] array = new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

try (ForkJoinPool pool = ForkJoinPool.commonPool()) {
    SumTask sumTask = new SumTask(array, 0, array.length);

    long result = pool.invoke(sumTask);
    System.out.println("Sum of [1..10] = " + result);
}

// Sum of [1..10] = 55</pre>
        <div>
            <ul>
                <li><strong>Performance Tips</strong>:
                    <ul>
                        <li><strong>Set a good threshold</strong>¬†(too small ‚Üí overhead, too large ‚Üí underutilization).</li>
                        <li><strong>Avoid blocking calls</strong>¬†in tasks (defeats work-stealing).</li>
                        <li><strong>Use¬†<code>commonPool()</code></strong> instead of creating new ForkJoinPool().</li>
                    </ul>
                </li>
                <li><strong>Use Case</strong>: Merge sort, Tree traversal, Matrix operations.</li>
            </ul>
        </div>
    </div>
</div>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Executor Framework</strong></h3>
<ul>
    <li>A powerful set of <strong data-start="157" data-end="183">interfaces and classes</strong> in Java used to manage and control <strong data-start="219" data-end="230">threads</strong> more efficiently and cleanly than using <code data-start="271" data-end="279">Thread</code> directly.</li>
    <li>It simplifies - Thread creation and management, Task submission, and Concurrency handling.</li>
    <li>Key components in Executor Framework are:
        <ul>
            <li>
                <h4>Executor</h4>
                <ul>
                    <li>Basic interface to execute a task.</li>
                    <li>Think of it as a way to <strong data-start="645" data-end="688">decouple task submission from execution</strong>.</li>
                    <li><strong>Key method</strong>:
                        <ul>
                            <li><code data-start="861" data-end="871">void execute(Runnable command)</code> ‚Äì<span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">¬†submits a fire-and-forget task</span></li>
                        </ul>
                    </li>
                    <li><strong data-start="798" data-end="810">Example</strong>:</li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<div>
    <div>
        <div>
<pre>Executor executor = Executors.newSingleThreadExecutor();
executor.execute(() -&gt; System.out.println("Running in background"));
((ExecutorService) executor).shutdown();    // Hack to shut down the executor

// Running in background</pre>
        </div>
    </div>
    <ul>
        <li style="list-style-type: none;">
            <ul>
                <li>
                    <h4>Future</h4>
                    <ul>
                        <li>Represents the¬†<strong>result of an asynchronous computation</strong>.</li>
                        <li><strong>Key methods</strong>:
                            <ul>
                                <li><code data-start="861" data-end="871">get()</code> ‚Äì blocks until result is available</li>
                                <li><code data-start="861" data-end="871">get(timeout, unit)</code> ‚Äì waits with a timeout</li>
                                <li><code data-start="861" data-end="871">isDone()</code> ‚Äì checks if computation is complete</li>
                                <li><code data-start="1327" data-end="1337">cancel()</code> ‚Äì attempts cancellation</li>
                            </ul>
                        </li>
                        <li>Limited functionality (no chaining or composition).</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
</div>
<ul>
    <li style="list-style-type: none;">
        <ul>
            <li>
                <h4>ExecutorService</h4>
                <ul>
                    <li>Manages a pool of threads and provides lifecycle methods.</li>
                    <li>Extends <code data-start="861" data-end="871">Executor</code> with methods
                        <ul>
                            <li><code data-start="880" data-end="890">submit(Callable task)</code> ‚Äì submits a value-returning task</li>
                            <li><code data-start="956" data-end="969">invokeAll()</code>|<code data-start="971" data-end="984">invokeAny()</code> ‚Äì for batch task execution</li>
                            <li><code data-start="913" data-end="925">shutdown()</code> ‚Äì graceful shutdown</li>
                            <li><code data-start="956" data-end="969">awaitTermination()</code> ‚Äì waits for shutdown</li>
                        </ul>
                    </li>
                    <li><strong data-start="798" data-end="810">Example</strong>:</li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<div>
    <div>
        <div>
<pre>static class MyCallable implements Callable&lt;Integer&gt; {

    @Override
    public Integer call() throws Exception {
        Thread.sleep(1000); // sleeps for a second
        return 1;
    }
}</pre>
        </div>
    </div>
    <div>
        <div>
<pre>ExecutorService executorService = Executors.newFixedThreadPool(2);
Future&lt;Integer&gt; future = executorService.submit(new MyCallable());
System.out.println("Task done: " + future.isDone());    // false
System.out.println("Future result: " + future.get());   // blocks until the task is done, then prints 1
executorService.shutdown();

// Task done: false
// Future result: 1</pre>
        </div>
    </div>
</div>
<ul>
    <li style="list-style-type: none;">
        <ul>
            <li>
                <h4>ScheduledExecutorService</h4>
                <ul>
                    <li>Allows to <strong data-start="1250" data-end="1302">schedule tasks with delays or periodic execution</strong>.</li>
                    <li><strong>Key methods</strong>:
                        <ul>
                            <li><code data-start="861" data-end="871">schedule()</code> ‚Äì <strong>schedules a one-time task</strong> to run after a specified delay</li>
                            <li><code data-start="861" data-end="871">scheduleAtFixedRate(timeout, unit)</code> ‚Äì <strong>schedules a task to run repeatedly</strong> at a <strong data-start="947" data-end="961">fixed rate</strong>, regardless of how long the task takes</li>
                            <li><code data-start="861" data-end="871">scheduleWithFixedDelay()</code> ‚Äì schedules a task to run repeatedly with a <strong data-start="1454" data-end="1469">fixed delay</strong> <strong data-start="1470" data-end="1506">after the previous task finishes</strong></li>
                        </ul>
                    </li>
                    <li><strong data-start="798" data-end="810">Example</strong>:</li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<div>
<pre>ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
scheduler.schedule(() -&gt; System.out.println("Delayed task"), 1, TimeUnit.SECONDS);
scheduler.scheduleAtFixedRate(() -&gt; System.out.println("Fixed-Rate scheduled task"), 1, 1, TimeUnit.SECONDS);
scheduler.scheduleWithFixedDelay(() -&gt; System.out.println("Fixed-Delay scheduled task"), 1, 2, TimeUnit.SECONDS);

Thread.sleep(3000); // Main thread sleeps for 3 seconds, so that scheduler can run a few iterations

scheduler.shutdown();
boolean terminated = scheduler.awaitTermination(5, TimeUnit.SECONDS);
System.out.println("Scheduler terminated: " + terminated);

// Delayed task
// Fixed-Rate scheduled task
// Fixed-Delay scheduled task
// Fixed-Rate scheduled task
// Fixed-Rate scheduled task
// Fixed-Delay scheduled task
// Scheduler terminated: true</pre>
</div>
<ul>
    <li style="list-style-type: none;">
        <ul>
            <li>
                <h4>ThreadPoolExecutor</h4>
                <ul>
                    <li><strong data-start="165" data-end="188">Core implementation</strong> of Java's thread pooling mechanism.</li>
                    <li>Offers <strong data-start="333" data-end="357">fine-grained control</strong> over threading behaviour, i.e., number of threads, task queue, thread life cycle, task rejection policy, etc.</li>
                    <li><strong>How ThreadPoolExecutor Works</strong>:
                        <ul>
                            <li>Maintains a¬†<strong>pool of worker threads</strong></li>
                            <li>Uses a¬†<strong>task queue</strong>¬†for holding pending tasks</li>
                            <li>Dynamically adjusts pool size between¬†<strong>core</strong>¬†and¬†<strong>maximum</strong>¬†pool sizes</li>
                            <li>Implements¬†<strong>thread reuse</strong>¬†to reduce overhead</li>
                        </ul>
                    </li>
                    <li><strong>Key Parameters</strong>:
                        <ul>
                            <li><code data-start="1821" data-end="1835">corePoolSize</code> ‚Äì minimum threads to keep alive, even if idle</li>
                            <li><code data-start="1821" data-end="1835">maximumPoolSize</code> ‚Äì maximum number of threads allowed</li>
                            <li><code data-start="1821" data-end="1835">keepAliveTime</code> ‚Äì maximum time that excess idle threads will wait before being killed</li>
                            <li><code data-start="1821" data-end="1835">unit</code> ‚Äì time unit for <code data-start="961" data-end="976">keepAliveTime</code></li>
                            <li><code data-start="1821" data-end="1835">workQueue</code> ‚Äì queue for holding pending tasks</li>
                            <li><code data-start="1821" data-end="1835">threadFactory</code> ‚Äì custom thread creation</li>
                            <li><code data-start="1821" data-end="1835">handler</code> ‚Äì policy to use for rejected tasks</li>
                        </ul>
                    </li>
                    <li><strong>Task Execution Flow</strong>:
                        <ul>
                            <li>New tasks go to¬†<strong>core threads</strong>¬†if available</li>
                            <li>If core threads busy, tasks go to¬†<strong>work queue</strong></li>
                            <li>If queue full, new threads created up to¬†<code>maximumPoolSize</code></li>
                            <li>If max threads reached,¬†<strong>rejection policy</strong>¬†triggers</li>
                        </ul>
                    </li>
                    <li><strong>Queue Strategies</strong>:
                        <ul>
                            <li><code data-start="1821" data-end="1835">ArrayBlockingQueue</code> ‚Äì bounded queue</li>
                            <li><code data-start="1821" data-end="1835">LinkedBlockingQueue</code> ‚Äì unbounded queue</li>
                            <li><code data-start="1821" data-end="1835">PriorityBlockingQueue</code> ‚Äì priority-based ordering</li>
                        </ul>
                    </li>
                    <li><strong>Rejection Policies</strong>:
                        <ul>
                            <li><code data-start="1821" data-end="1835">AbortPolicy</code> (default) ‚Äì throws¬†<code>RejectedExecutionException</code></li>
                            <li><code data-start="1821" data-end="1835">CallerRunsPolicy</code> ‚Äì executes task in caller's thread</li>
                            <li><code data-start="1821" data-end="1835">DiscardPolicy</code> ‚Äì silently discards task</li>
                            <li><code data-start="1821" data-end="1835">DiscardOldestPolicy</code> ‚Äì discards¬†oldest queued task</li>
                        </ul>
                    </li>
                    <li><strong data-start="798" data-end="810">Example</strong>:</li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<div>
    <div>
<pre>ThreadPoolExecutor tpe = new ThreadPoolExecutor(
        2,  // Core threads
        3, // Max threads
        60, // Keep-alive
        TimeUnit.SECONDS,
        new ArrayBlockingQueue&lt;&gt;(5),  // Bounded queue
        Executors.defaultThreadFactory(),
        new ThreadPoolExecutor.CallerRunsPolicy()   // Fallback
);

// Submit tasks
for (int i = 0; i &lt; 10; i++) {
    tpe.execute(() -&gt; {
        System.out.printf("Task running in %s [Active threads: %d, Queue size: %d, Completed tasks: %d]%n",
                Thread.currentThread().getName(), tpe.getActiveCount(), tpe.getQueue().size(), tpe.getCompletedTaskCount());
    });
}

tpe.shutdown(); // Graceful shutdown

// Task running in pool-4-thread-1 [Active threads: 2, Queue size: 0, Completed tasks: 0]
// Task running in pool-4-thread-2 [Active threads: 2, Queue size: 5, Completed tasks: 0]
// Task running in main [Active threads: 3, Queue size: 5, Completed tasks: 0]
// Task running in pool-4-thread-3 [Active threads: 3, Queue size: 5, Completed tasks: 0]
// Task running in pool-4-thread-3 [Active threads: 3, Queue size: 3, Completed tasks: 3]
// Task running in pool-4-thread-3 [Active threads: 3, Queue size: 2, Completed tasks: 4]
// Task running in pool-4-thread-1 [Active threads: 3, Queue size: 4, Completed tasks: 1]
// Task running in pool-4-thread-2 [Active threads: 3, Queue size: 3, Completed tasks: 2]
// Task running in pool-4-thread-3 [Active threads: 3, Queue size: 1, Completed tasks: 5]
// Task running in pool-4-thread-1 [Active threads: 3, Queue size: 0, Completed tasks: 6]</pre>
    </div>
</div>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ CompletableFuture</strong></h3>
<ul>
    <li>
        <div></div></li>
</ul>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ ThreadLocal variables</strong></h3>
<ul>
    <li>
        <div></div></li>
</ul>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Semaphore</strong></h3>
<ul>
    <li>
        <div></div></li>
</ul>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ RateLimiter</strong></h3>
<ul>
    <li>
        <div></div></li>
</ul>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Count Down Latch</strong></h3>
<ul>
    <li>
        <div></div></li>
</ul>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Phaser</strong></h3>
<ul>
    <li>
        <div></div></li>
</ul>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ LockSupport</strong></h3>
<ul>
    <li>
        <div></div></li>
</ul>

<hr class="" data-start="733" data-end="736" />

<h3 class="" data-start="738" data-end="767"><strong data-start="742" data-end="765">üîπ Virtual Threads</strong></h3>
<ul>
    <li></li>
</ul>

<hr class="" data-start="733" data-end="736" />

&nbsp;