<!-- wp:paragraph -->
<p class="" data-start="45" data-end="193"><!-- wp:paragraph --></p>
<p class="" data-start="85" data-end="320">Data structures are the <strong data-start="109" data-end="146">backbone of efficient programming</strong>. Whether you're handling large datasets, optimizing performance, or preparing for coding interviews, understanding Java‚Äôs built-in and custom data structures is essential.</p>
<p class="" data-start="322" data-end="595">In this guide, we‚Äôll explore <strong data-start="351" data-end="388">all significant data structures in Java</strong>, from basic arrays to advanced trees and graphs. You'll learn:<br data-start="451" data-end="454" />‚úîÔ∏è When to use each data structure<br data-start="488" data-end="491" />‚úîÔ∏è Code examples for hands-on learning<br data-start="526" data-end="529" />‚úîÔ∏è Real-world use cases</p>
<p class="" data-start="597" data-end="757">By the end of this guide, you'll have a <strong data-start="637" data-end="660">solid understanding</strong> of Java data structures and be able to choose the right one for any problem. Let‚Äôs dive in! üöÄ</p>
<hr class="" data-start="195" data-end="198" />
<h2 style="text-align: center;"><strong data-start="238" data-end="281">Array</strong></h2>
<ul>
    <li data-start="286" data-end="347"><strong data-start="286" data-end="300">Fixed-size</strong>, stores elements <strong data-start="318" data-end="334">contiguously</strong> in memory.</li>
    <li data-start="350" data-end="420"><strong data-start="350" data-end="372">Fast random access</strong> (<code data-start="374" data-end="380">O(1)</code>), but resizing is expensive (<code data-start="410" data-end="416">O(n)</code>).</li>
    <li data-start="423" data-end="468"><strong data-start="423" data-end="435">Example:</strong></li>
</ul>
<div>
<pre>private void array() {
    // Fixed-size array
    int[] array = new int[10];
    array[4] = 5;

    // Dynamic array
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    list.add(1);
    list.addFirst(0);

    System.out.println("Array output:\t array: " + Arrays.toString(array) + ", list: " + list);
    // array: [0, 0, 0, 0, 5, 0, 0, 0, 0, 0], list: [0, 1]
}</pre>
</div>
<ul>
    <li data-start="471" data-end="527"><strong data-start="471" data-end="484">Use Case:</strong> Static lists, lookup-heavy applications.</li>
    <li><strong data-start="6251" data-end="6282">Use <code data-start="6257" data-end="6268">ArrayList</code> over arrays</strong> for dynamic storage.</li>
</ul>
<hr class="" data-start="195" data-end="198" />
<h2 style="text-align: center;" data-start="200" data-end="233"><strong data-start="203" data-end="233">String</strong></h2>
<ul>
    <li data-start="575" data-end="643"><strong>An immutable</strong>¬†sequence of characters, implemented as a <strong data-start="2225" data-end="2237"><code data-start="2227" data-end="2235">char[]</code></strong> internally.</li>
    <li data-start="575" data-end="643"><strong data-start="2563" data-end="2588">Stored in String Pool</strong> for optimization.</li>
    <li data-start="798" data-end="861"><strong data-start="798" data-end="810">Example:</strong></li>
</ul>
<div>
    <div>
<pre>private void string() {
    // Immutable
    String str = "Hello";
    str = str + " World"; // A new object is created, old one is discarded

    // Mutable, fast
    StringBuilder sb = new StringBuilder("Hello");
    sb.append(" ").append("World");

    // Thread-safe
    StringBuffer sbuf = new StringBuffer("Hello");
    sbuf.append(" ").append("World").append('!');

    System.out.println("String output:\t str: " + str + ", sb: " + sb + ", sbuf: " + sbuf);
    // str: Hello World, sb: Hello World, sbuf: Hello World!
}</pre>
    </div>
</div>
<ul>
    <li data-start="798" data-end="861"><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="864" data-end="877">Use Case:</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> Text processing, encoding, and pattern matching.</span></li>
</ul>
<hr class="" data-start="195" data-end="198" />
<h2 style="text-align: center;" data-start="920" data-end="952"><strong data-start="533" data-end="570">Linked List</strong></h2>
<ul>
    <li data-start="575" data-end="643"><strong data-start="575" data-end="591">Dynamic size</strong>, each element (node) has a reference to the next.</li>
    <li data-start="646" data-end="718"><strong data-start="646" data-end="684">Fast insertions/deletions (<code data-start="675" data-end="681">O(1)</code>)</strong>, but <strong data-start="690" data-end="715">slow lookups (<code data-start="706" data-end="712">O(n)</code>)</strong>.</li>
    <li data-start="721" data-end="795"><strong data-start="721" data-end="731">Types:</strong> Singly Linked List, Doubly Linked List, Circular Linked List.</li>
    <li><strong data-start="798" data-end="810">Example:</strong></li>
</ul>
<div>
<pre>private void list() {
    // Use ArrayList for fast access (random access) to elements and fewer insertions/removals.
    List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();
    arrayList.add(1);
    arrayList.add(2);

    // Use LinkedList for frequent insertions/deletions at the beginning or middle, but not random access.
    List&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;();
    linkedList.addFirst(5);
    linkedList.add(7);
    linkedList.add(1, 6);

    System.out.println("List output:\t arrayList: [" + arrayList.get(0) + ", " + arrayList.get(1) + "], linkedList: " + linkedList);
    // arrayList: [1, 2], linkedList: [5, 6, 7]
}</pre>
</div>
<ul>
    <li><strong data-start="864" data-end="877">Use Case:</strong> Undo operations, chaining in HashMaps.</li>
</ul>
<hr class="" data-start="195" data-end="198" />
<h2 style="text-align: center;" data-start="920" data-end="952"><strong data-start="533" data-end="570">Map</strong></h2>
<ul>
    <li data-start="575" data-end="643"><strong data-start="1815" data-end="1834">Stores key-value pairs</strong>, and provides <strong style="font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="1845" data-end="1870">fast lookups </strong><span style="font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">based on keys.</span></li>
    <li data-start="575" data-end="643"><strong data-start="319" data-end="334">Unique keys</strong>, and values can be duplicated.</li>
    <li><strong data-start="798" data-end="810">Example:</strong></li>
</ul>
<div>
    <div>
        <pre>private void map() {<br />    // HashMap: No order guarantee, fast lookups (O(1))<br />    Map&lt;Integer, String&gt; hashMap = new HashMap&lt;&gt;();<br />    hashMap.put(3, "C++");<br />    hashMap.put(1, "Java");<br />    hashMap.put(2, "Python");<br /><br />    // TreeMap: Sorted by keys (Natural Ordering)<br />    Map&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;(hashMap);<br /><br />    // LinkedHashMap: Maintains insertion order<br />    Map&lt;Integer, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();<br />    linkedHashMap.put(3, "C++");<br />    linkedHashMap.put(1, "Java");<br />    linkedHashMap.put(2, "Python");<br /><br />    System.out.println("Map output:\t\t hashMap: " + hashMap + ", treeMap: " + treeMap + ", linkedHashMap: " + linkedHashMap);<br />    // hashMap: {1=Java, 2=Python, 3=C++}, treeMap: {1=Java, 2=Python, 3=C++}, linkedHashMap: {3=C++, 1=Java, 2=Python}<br />}</pre>
    </div>
</div>
<ul>
    <li><strong data-start="1939" data-end="1952">Use Case:</strong> Caching, indexing, counting occurrences.</li>
</ul>
<hr class="" data-start="195" data-end="198" />
<h2 style="text-align: center;" data-start="920" data-end="952"><strong data-start="533" data-end="570">Set</strong></h2>
<ul>
    <li><strong data-start="2329" data-end="2355">Stores unique elements</strong>, no duplicates allowed.</li>
    <li><strong data-start="1227" data-end="1259">Efficient membership testing</strong> (contains operation).</li>
    <li><strong data-start="798" data-end="810">Example:</strong></li>
</ul>
<div>
    <div>
        <pre>private void set() {<br />    // HashSet: Unordered, fast access (O(1)), internally uses a HashMap<br />    Set&lt;String&gt; hashSet = new HashSet&lt;&gt;();<br />    hashSet.add("Java");<br />    hashSet.add("Python");<br />    hashSet.add("C++");<br /><br />    // TreeSet: Sorted order (Natural Ordering)<br />    Set&lt;String&gt; treeSet = new TreeSet&lt;&gt;(hashSet);<br /><br />    // LinkedHashSet: Maintains insertion order<br />    Set&lt;String&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();<br />    linkedHashSet.add("Java");<br />    linkedHashSet.add("Python");<br />    linkedHashSet.add("C++");<br /><br />    System.out.println("Set output:\t\t hashSet: " + hashSet + ", treeSet: " + treeSet + ", linkedHashSet: " + linkedHashSet);<br />    // hashSet: [Java, C++, Python], treeSet: [C++, Java, Python], linkedHashSet: [Java, Python, C++]<br />}</pre>
    </div>
</div>
<ul>
    <li><strong data-start="2502" data-end="2515">Use Case:</strong> Removing duplicates, membership checks.</li>
</ul>
<hr class="" data-start="195" data-end="198" />
<h2 style="text-align: center;" data-start="920" data-end="952"><strong style="font-family: inherit; font-style: inherit;" data-start="924" data-end="950">Stack</strong></h2>
<ul>
    <li data-start="955" data-end="997"><strong data-start="955" data-end="984">LIFO (Last In, First Out)</strong> structure.</li>
    <li data-start="1000" data-end="1042"><strong data-start="1000" data-end="1030">Push, Pop, Peek operations</strong> (<code data-start="1032" data-end="1038">O(1)</code>).</li>
    <li data-start="1045" data-end="1099"><strong data-start="1045" data-end="1057">Example:</strong></li>
</ul>
<div>
<pre>private void stack() {
    // Stack (Legacy API) is a subclass of Vector, which is synchronized and generally slower due to thread safety overhead.
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    stack.push(10);
    stack.pop();

    // ArrayDeque is not synchronized (unlike Stack, which extends Vector) and does not suffer from resizing overhead like an ArrayList-based stack.
    Deque&lt;Integer&gt; arrayDequeAsStack = new ArrayDeque&lt;&gt;(); // Recommended to use as Stack for java implementations
    arrayDequeAsStack.push(10);
    arrayDequeAsStack.push(20);
    arrayDequeAsStack.push(30);
    arrayDequeAsStack.pop();

    System.out.println("Stack output:\t top element: " + arrayDequeAsStack.peek() + ", arrayDequeAsStack:  " + arrayDequeAsStack);
    // top element: 20, arrayDequeAsStack:  [20, 10]
}</pre>
</div>
<ul>
    <li data-start="1102" data-end="1164"><strong data-start="1102" data-end="1115">Use Case:</strong> Backtracking, function calls, browser history.</li>
</ul>
<hr class="" data-start="195" data-end="198" />
<h2 style="text-align: center;" data-start="1166" data-end="1216"><strong data-start="1170" data-end="1214">Queue</strong></h2>
<ul>
    <li data-start="1219" data-end="1262"><strong data-start="1219" data-end="1249">FIFO (First In, First Out)</strong> structure.</li>
    <li data-start="1265" data-end="1313"><strong data-start="1265" data-end="1280">Operations:</strong> <code data-start="1281" data-end="1288">add()</code>, <code data-start="1290" data-end="1300">remove()</code>, <code data-start="1302" data-end="1310">peek()</code>.</li>
    <li data-start="1316" data-end="1375"><strong data-start="1316" data-end="1328">Example:</strong></li>
</ul>
<div>
<pre>private void queue() {
    // LinkedList uses a doubly linked list, which requires O(1) for enqueue/dequeue but has extra memory overhead (pointers for each node).
    // LinkedList suffers from pointer chasing, which increases cache misses and degrades performance.
    Queue&lt;Integer&gt; linkedListAsQueue = new LinkedList&lt;&gt;();
    linkedListAsQueue.add(10);
    linkedListAsQueue.remove();

    // ArrayDeque is backed by a resizable array, providing O(1) time complexity for enqueue (offer/add) and dequeue (poll/remove) operations.
    // ArrayDeque has a better cache locality (since arrays are stored contiguously in memory), making it faster in practice.
    Queue&lt;Integer&gt; arrayDequeAsQueue = new ArrayDeque&lt;&gt;(); // Faster than LinkedList and Recommended to use as Queue for Java implementations
    // Enqueue elements
    arrayDequeAsQueue.offer(10);
    arrayDequeAsQueue.offer(20);
    arrayDequeAsQueue.offer(30);
    // Dequeue elements
    arrayDequeAsQueue.poll();

    System.out.println("Queue output:\t top element: " + arrayDequeAsQueue.peek() + ", arrayDequeAsQueue: " + arrayDequeAsQueue);
    // top element: 20, arrayDequeAsQueue: [20, 30]
}</pre>
</div>
<ul>
    <li data-start="1378" data-end="1429"><strong data-start="1378" data-end="1391">Use Case:</strong> Job scheduling, request processing.</li>
</ul>
<hr class="" data-start="195" data-end="198" />
<h2 style="text-align: center;" data-start="1431" data-end="1481"><strong data-start="1435" data-end="1479">Deque</strong></h2>
<ul>
    <li data-start="1484" data-end="1552"><strong data-start="1484" data-end="1506">A double-ended queue</strong>, allows insertions/removals from both ends.</li>
    <li data-start="1555" data-end="1610"><strong data-start="1555" data-end="1584">Faster than Stack &amp; Queue</strong> in some cases (<code data-start="1600" data-end="1606">O(1)</code>).</li>
    <li data-start="1613" data-end="1672"><strong data-start="1613" data-end="1625">Example: </strong>Refer Stack/Queue example.</li>
    <li data-start="1675" data-end="1728"><strong data-start="1675" data-end="1688">Use Case:</strong> Sliding window problems, palindromes.</li>
</ul>
<hr class="" data-start="1730" data-end="1733" />
<h2 style="text-align: center;" data-start="1773" data-end="1812"><strong data-start="4110" data-end="4153">Priority Queue</strong></h2>
<ul>
    <li data-start="4158" data-end="4203"><strong data-start="4158" data-end="4201">Elements are ordered based on priority.</strong></li>
    <li data-start="4206" data-end="4247"><strong data-start="4206" data-end="4244">Implemented as a Heap (<code data-start="4231" data-end="4241">O(log n)</code>)</strong>.</li>
    <li data-start="4250" data-end="4317"><strong data-start="4250" data-end="4262">Example:</strong></li>
</ul>
<div>
<pre>private void priorityQueue() {
    PriorityQueue&lt;Integer&gt; priorityQueueAsMinHeap = new PriorityQueue&lt;&gt;(); // Min-Heap
    // Adding elements
    priorityQueueAsMinHeap.offer(30);
    priorityQueueAsMinHeap.offer(10);
    priorityQueueAsMinHeap.offer(20);
    priorityQueueAsMinHeap.offer(5);
    // Removing elements
    priorityQueueAsMinHeap.poll();

    PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Collections.reverseOrder()); // Max-Heap

    System.out.println("Heap output:\t top element: " + priorityQueueAsMinHeap.peek() + ", priorityQueueAsMinHeap: " + priorityQueueAsMinHeap);
    // top element: 10, priorityQueueAsMinHeap: [10, 30, 20]
}</pre>
</div>
<ul>
    <li data-start="4320" data-end="4369"><strong data-start="4320" data-end="4333">Use Case:</strong> Scheduling, Dijkstra‚Äôs Algorithm.</li>
</ul>
<hr class="" data-start="1730" data-end="1733" />
<h2 style="text-align: center;" data-start="1773" data-end="1812"><strong data-start="3221" data-end="3255">Binary Tree</strong></h2>
<ul>
    <li data-start="3260" data-end="3313"><strong data-start="3260" data-end="3296">Each node has at most 2 children</strong> (left, right).</li>
    <li data-start="3316" data-end="3364"><strong data-start="3316" data-end="3362">Used for hierarchical data representation.</strong></li>
    <li data-start="3367" data-end="3381"><strong data-start="3367" data-end="3379">Example:</strong></li>
</ul>
<div>
<pre>class TreeNode&lt;T&gt; {
    T data;
    TreeNode&lt;T&gt; left, right;

    public TreeNode(T data) {
        this.data = data;
        this.left = this.right = null;
    }
}

class BinaryTree&lt;T&gt; {
    TreeNode&lt;T&gt; root;

    public BinaryTree(T rootData) {
        this.root = new TreeNode&lt;&gt;(rootData);
    }

    // Inorder Traversal (Left -&gt; Root -&gt; Right)
    public void inorder(TreeNode&lt;T&gt; node) {
        if (node == null) return;
        inorder(node.left);
        System.out.print(node.data + " ");
        inorder(node.right);
    }

    // Level Order Traversal (BFS)
    public void levelOrder() {
        if (root == null) return;

        Queue&lt;TreeNode&lt;T&gt;&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);

        while (!queue.isEmpty()) {
            TreeNode&lt;T&gt; current = queue.poll();
            System.out.print(current.data + " ");

            if (current.left != null) queue.offer(current.left);
            if (current.right != null) queue.offer(current.right);
        }
    }
}

private void tree() {
    // Create a binary tree
    BinaryTree&lt;Integer&gt; tree = new BinaryTree&lt;&gt;(1);
    // Manually create left and right children
    tree.root.left = new TreeNode&lt;&gt;(2);
    tree.root.right = new TreeNode&lt;&gt;(3);
    tree.root.left.left = new TreeNode&lt;&gt;(4);
    tree.root.left.right = new TreeNode&lt;&gt;(5);
    tree.root.right.left = new TreeNode&lt;&gt;(6);
    tree.root.right.right = new TreeNode&lt;&gt;(7);

    System.out.print("Tree output:\t level order traversal: ");
    tree.levelOrder();
    // level order traversal: 1 2 3 4 5 6 7
}</pre>
</div>
<ul>
    <li data-start="3466" data-end="3525"><strong data-start="3466" data-end="3479">Use Case:</strong> Search trees, expression trees, game trees.</li>
</ul>
<hr class="" data-start="1730" data-end="1733" />
<h2 style="text-align: center;" data-start="1773" data-end="1812"><strong data-start="3221" data-end="3255">Binary Search Tree</strong></h2>
<ul>
    <li data-start="2039" data-end="2105"><strong data-start="3568" data-end="3604">Sorted tree, left &lt; root &lt; right</strong>.</li>
    <li data-start="2108" data-end="2157"><strong data-start="3610" data-end="3665">Search, Insert, Delete operations take (<code data-start="3652" data-end="3662">O(log n)</code>)</strong>.</li>
    <li data-start="2108" data-end="2157"><strong data-start="2710" data-end="2767">Unbalanced BST can degrade to O(n) (linked list form)</strong>.</li>
    <li data-start="2160" data-end="2228"><strong data-start="2160" data-end="2172">Example:</strong></li>
</ul>
<div>
    <div>
<pre>class BinarySearchTree {
    private TreeNode&lt;Integer&gt; root;

    public void insert(int key) {
        root = insertElement(root, key);
    }

    private TreeNode&lt;Integer&gt; insertElement(TreeNode&lt;Integer&gt; root, int key) {
        if (root == null) return new TreeNode&lt;&gt;(key);
        if (key &lt; root.data) root.left = insertElement(root.left, key);
        else if (key &gt; root.data) root.right = insertElement(root.right, key);
        return root;
    }

    public boolean search(int key) {
        return searchElement(root, key);
    }

    private boolean searchElement(TreeNode&lt;Integer&gt; root, int key) {
        if (root == null) return false;
        if (key == root.data) return true;
        return key &lt; root.data ? searchElement(root.left, key) : searchElement(root.right, key);
    }

    public void inorder() {
        inorderTraversal(root);
    }

    private void inorderTraversal(TreeNode&lt;Integer&gt; root) {
        if (root != null) {
            inorderTraversal(root.left);
            System.out.print(root.data + " ");
            inorderTraversal(root.right);
        }
    }
}

private void binarySearchTree() {
    BinarySearchTree bst = new BinarySearchTree();
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(2);
    bst.insert(4);
    bst.insert(6);
    bst.insert(8);

    // Displaying the BST (keys are sorted)
    System.out.print("BST output:\t\t search 4: " + bst.search(4) + ", search 7: " + bst.search(7) + ", in-order traversal: ");
    bst.inorder();
    // search 4: true, search 7: false, in-order traversal: 2 3 4 5 6 8 9
}</pre>
    </div>
</div>
<ul>
    <li data-start="2231" data-end="2288"><strong data-start="3707" data-end="3720">Use Case:</strong> Auto-suggestions, range queries.</li>
</ul>
<hr class="" data-start="1730" data-end="1733" />
<h2 style="text-align: center;" data-start="1773" data-end="1812"><strong data-start="2001" data-end="2034">Red-Black Tree</strong></h2>
<ul>
    <li data-start="2039" data-end="2105"><strong data-start="3012" data-end="3034">Self-balancing BST</strong> that ensures logarithmic time complexity <strong data-start="3610" data-end="3665">(<code data-start="3652" data-end="3662">O(log n)</code>)</strong>¬†for insertion, deletion, and search operations.</li>
    <li data-start="2108" data-end="2157"><strong data-start="2108" data-end="2139">Slower lookups (<code data-start="2126" data-end="2136">O(log n)</code>)</strong> than <code data-start="2145" data-end="2154">HashMap</code>.</li>
    <li data-start="2108" data-end="2157"><code data-start="2046" data-end="2055">TreeMap</code> and <code data-start="2060" data-end="2069">TreeSet</code> internally use <strong data-start="2085" data-end="2104">Red-Black Trees</strong>.</li>
    <li data-start="2160" data-end="2228"><strong data-start="2160" data-end="2172">Example:</strong></li>
</ul>
<div>
<pre>private void redBlackTree() {
    // A TreeMap in Java is a sorted map implementation based on a Red-Black Tree.
    // It maintains keys in sorted order and provides O(log n) time complexity for insertion, deletion, and lookup.
    TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;(); // keys sorted in natural order
    // Adding key-value pairs
    treeMap.put(3, "Three");
    treeMap.put(1, "One");
    treeMap.put(2, "Two");
    treeMap.put(5, "Five");
    treeMap.put(4, "Four");
    // Removing an entry
    treeMap.remove(2);

    Map&lt;Integer, String&gt; descTreeMap = new TreeMap&lt;&gt;(Comparator.reverseOrder()); // keys sorted in descending order

    // Displaying the TreeMap (keys are sorted)
    System.out.println("RedBlackTree:\t first key: " + treeMap.firstKey() + ", last key: " + treeMap.lastKey() + ", treeMap: " + treeMap);
    // first key: 1, last key: 5, treeMap: {1=One, 3=Three, 4=Four, 5=Five}
}</pre>
</div>
<ul>
    <li data-start="2160" data-end="2228"><strong style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';" data-start="2231" data-end="2244">Use Case:</strong><span style="font-size: inherit; font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';"> Ordered key-value storage, range queries.</span></li>
</ul>
<hr class="" data-start="1730" data-end="1733" />
<h2 style="text-align: center;" data-start="1773" data-end="1812"><strong data-start="3221" data-end="3255">Graph</strong></h2>
<ul>
    <li data-start="2039" data-end="2105"><strong data-start="2903" data-end="2958">Used to represent networks (social, transport, web)</strong>.</li>
    <li data-start="2108" data-end="2157"><strong data-start="2964" data-end="2974">Types:</strong> <strong>Directed</strong> (edges have direction), <strong>Undirected</strong> (edges have no direction), <strong>Weighted</strong> (edges have weights), <strong>Unweighted</strong> (all edges are equal).</li>
    <li data-start="2108" data-end="2157"><strong>Representations:</strong> <strong>Adjacency List</strong> (efficient for sparse graphs), <strong>Adjacency Matrix</strong> (efficient for dense graphs).</li>
    <li data-start="2160" data-end="2228"><strong data-start="2160" data-end="2172">Example:</strong></li>
</ul>
<div>
    <div>
<pre>class Graph {
    private final Map&lt;Integer, List&lt;Integer&gt;&gt; adjList;

    public Graph() {
        this.adjList = new HashMap&lt;&gt;();
    }

    // Add a vertex
    public void addVertex(int vertex) {
        adjList.putIfAbsent(vertex, new ArrayList&lt;&gt;());
    }

    // Add an edge (undirected)
    public void addEdge(int src, int dest) {
        adjList.putIfAbsent(src, new ArrayList&lt;&gt;());
        adjList.putIfAbsent(dest, new ArrayList&lt;&gt;());
        adjList.get(src).add(dest);
        adjList.get(dest).add(src);
    }

    // Print the graph
    public void printGraph() {
        for (var entry : adjList.entrySet()) {
            System.out.print(entry.getKey() + " -&gt; " + entry.getValue() + "; ");
        }
    }
}

private void graph() {
    Graph graph = new Graph();
    graph.addVertex(1);
    graph.addVertex(2);
    graph.addVertex(3);
    graph.addVertex(4);
    graph.addEdge(1, 2);
    graph.addEdge(2, 3);
    graph.addEdge(3, 4);
    graph.addEdge(4, 1);

    // Displaying the Graph
    System.out.print("Graph output:\t ");
    graph.printGraph();
    // 1 -&gt; [2, 4]; 2 -&gt; [1, 3]; 3 -&gt; [2, 4]; 4 -&gt; [3, 1];
}</pre>
    </div>
</div>
<ul>
    <li data-start="2231" data-end="2288"><strong data-start="3145" data-end="3158">Use Case:</strong> Route finding (Dijkstra‚Äôs Algorithm), Social Networks.</li>
</ul>
<hr class="" data-start="1730" data-end="1733" />
<h2 style="text-align: center;" data-start="1773" data-end="1812"><strong data-start="3221" data-end="3255">Trie</strong></h2>
<ul>
    <li data-start="2039" data-end="2105"><strong data-start="3792" data-end="3866">Used for fast prefix-based searching (<code data-start="3832" data-end="3838">O(m)</code>, where <code data-start="3846" data-end="3849">m</code> is key length)</strong>.</li>
    <li data-start="2160" data-end="2228"><strong data-start="2160" data-end="2172">Example:</strong></li>
</ul>
<div>
    <div>
<pre>class TrieNode {
    Map&lt;Character, TrieNode&gt; children = new HashMap&lt;&gt;();
    boolean endOfWord;

    public TrieNode() {
        this.endOfWord = false;
    }
}

class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    // Insert a word into the trie
    public void insert(String word) {
        TrieNode node = root;
        for (char ch : word.toCharArray()) {
            node.children.putIfAbsent(ch, new TrieNode());
            node = node.children.get(ch);
        }
        node.endOfWord = true;
    }

    // Search for a word in the trie
    public boolean search(String word) {
        TrieNode node = root;
        for (char ch : word.toCharArray()) {
            if (!node.children.containsKey(ch)) {
                return false;
            }
            node = node.children.get(ch);
        }
        return node.endOfWord;
    }

    // Check if a prefix exists in the trie
    public boolean startsWith(String prefix) {
        TrieNode node = root;
        for (char ch : prefix.toCharArray()) {
            if (!node.children.containsKey(ch)) {
                return false;
            }
            node = node.children.get(ch);
        }
        return true;
    }
}

private void trie() {
    Trie trie = new Trie();
    trie.insert("apple");
    trie.insert("app");
    trie.insert("application");

    System.out.println("Trie output:\t " +
                       "search 'apple': " + trie.search("apple") +
                       ", search 'app': " + trie.search("app") +
                       ", search 'appl': " + trie.search("appl") +
                       ", starts with 'app': " + trie.startsWith("app"));
    // search 'apple': true, search 'app': true, search 'appl': false, starts with 'app': true
}</pre>
    </div>
</div>
<ul>
    <li data-start="2231" data-end="2288"><strong data-start="4014" data-end="4027">Use Case:</strong> Auto-complete, spell checkers, word games.</li>
</ul>
<hr class="" data-start="5001" data-end="5004" />
<h2 class="" style="text-align: center;" data-start="5006" data-end="5029"><strong data-start="5009" data-end="5029">Summary Table</strong></h2>
<div class="overflow-x-auto contain-inline-size">
    <table style="height: 659px;" width="1275" data-start="5030" data-end="6217">
        <thead data-start="5030" data-end="5125">
        <tr data-start="5030" data-end="5125">
            <th data-start="5030" data-end="5051"><strong data-start="5032" data-end="5050">Data Structure</strong></th>
            <th data-start="5051" data-end="5080"><strong data-start="5053" data-end="5079">Implementation in Java</strong></th>
            <th data-start="5080" data-end="5108"><strong data-start="5082" data-end="5107">Time Complexity (Avg)</strong></th>
            <th data-start="5108" data-end="5125"><strong data-start="5110" data-end="5123">Use Cases</strong></th>
        </tr>
        </thead>
        <tbody data-start="5222" data-end="6217">
        <tr data-start="5222" data-end="5336">
            <td><strong data-start="5224" data-end="5233">Array</strong></td>
            <td><code data-start="5236" data-end="5262">int[] arr = new int[10];</code></td>
            <td><code data-start="5265" data-end="5271">O(1)</code> lookup, <code data-start="5280" data-end="5286">O(n)</code> insert/delete</td>
            <td>Static lists, lookup-heavy apps</td>
        </tr>
        <tr data-start="5337" data-end="5449">
            <td><strong data-start="5339" data-end="5354">Linked List</strong></td>
            <td><code data-start="5357" data-end="5372">LinkedList&lt;E&gt;</code></td>
            <td><code data-start="5375" data-end="5381">O(1)</code> insert/delete, <code data-start="5397" data-end="5403">O(n)</code> search</td>
            <td>Undo history, chaining in HashMaps</td>
        </tr>
        <tr data-start="5450" data-end="5520">
            <td><strong data-start="5452" data-end="5461">Stack</strong></td>
            <td><code data-start="5464" data-end="5474">Stack&lt;E&gt;</code></td>
            <td><code data-start="5477" data-end="5483">O(1)</code> push/pop</td>
            <td>Backtracking, recursion</td>
        </tr>
        <tr data-start="5521" data-end="5607">
            <td><strong data-start="5523" data-end="5532">Queue</strong></td>
            <td><code data-start="5535" data-end="5545">Queue&lt;E&gt;</code></td>
            <td><code data-start="5548" data-end="5554">O(1)</code> enqueue/dequeue</td>
            <td>Job scheduling, request handling</td>
        </tr>
        <tr data-start="5608" data-end="5703">
            <td><strong data-start="5610" data-end="5619">Deque</strong></td>
            <td><code data-start="5622" data-end="5632">Deque&lt;E&gt;</code></td>
            <td><code data-start="5635" data-end="5641">O(1)</code> push/pop at both ends</td>
            <td>Sliding window, palindrome checking</td>
        </tr>
        <tr data-start="5704" data-end="5801">
            <td><strong data-start="5706" data-end="5717">HashMap</strong></td>
            <td><code data-start="5720" data-end="5735">HashMap&lt;K, V&gt;</code></td>
            <td><code data-start="5738" data-end="5744">O(1)</code> lookup, <code data-start="5753" data-end="5759">O(n)</code> worst case</td>
            <td>Caching, key-value storage</td>
        </tr>
        <tr data-start="5802" data-end="5875">
            <td><strong data-start="5804" data-end="5815">TreeMap</strong></td>
            <td><code data-start="5818" data-end="5833">TreeMap&lt;K, V&gt;</code></td>
            <td><code data-start="5836" data-end="5846">O(log n)</code></td>
            <td>Sorted key-value storage</td>
        </tr>
        <tr data-start="5876" data-end="5956">
            <td><strong data-start="5878" data-end="5887">Graph</strong></td>
            <td><code data-start="5890" data-end="5906">Adjacency List</code></td>
            <td><code data-start="5909" data-end="5917">O(V+E)</code> traversal</td>
            <td>Networks, shortest paths</td>
        </tr>
        <tr data-start="5957" data-end="6047">
            <td><strong data-start="5959" data-end="5974">Binary Tree</strong></td>
            <td><code data-start="5977" data-end="5987">TreeNode</code></td>
            <td><code data-start="5990" data-end="6000">O(log n)</code> search</td>
            <td>Hierarchical data, expression trees</td>
        </tr>
        <tr data-start="6048" data-end="6125">
            <td><strong data-start="6050" data-end="6058">Trie</strong></td>
            <td><code data-start="6061" data-end="6071">TrieNode</code></td>
            <td><code data-start="6074" data-end="6080">O(m)</code> search</td>
            <td>Auto-complete, dictionary storage</td>
        </tr>
        <tr data-start="6126" data-end="6217">
            <td><strong data-start="6128" data-end="6146">Priority Queue</strong></td>
            <td><code data-start="6149" data-end="6167">PriorityQueue&lt;E&gt;</code></td>
            <td><code data-start="6170" data-end="6180">O(log n)</code></td>
            <td>Scheduling, Dijkstra‚Äôs Algorithm</td>
        </tr>
        </tbody>
    </table>
</div>
<hr class="" data-start="6219" data-end="6222" />
<h2 class="" style="text-align: center;" data-start="6224" data-end="6248"><strong data-start="6227" data-end="6248">Final Thoughts</strong></h2>
<ul>
    <li data-start="116" data-end="178"><strong data-start="116" data-end="126">Arrays</strong>: O(1) random access, but O(n) insertion/deletion.</li>
    <li data-start="181" data-end="250"><strong data-start="181" data-end="197">Linked Lists</strong>: O(1) insert/delete at head/tail, but O(n) search.</li>
    <li data-start="659" data-end="754"><strong data-start="659" data-end="684">HashMap</strong>: O(1) average-time operations, but O(n) worst-case with collisions.</li>
    <li data-start="253" data-end="311"><strong data-start="253" data-end="272">Stacks &amp; Queues</strong>: O(1) insertion/deletion at one end.</li>
    <li data-start="314" data-end="393"><strong data-start="314" data-end="333">Heaps (Min/Max)</strong>: O(log n) insert/delete due to heap property maintenance.</li>
    <li data-start="396" data-end="484"><strong data-start="396" data-end="404">BSTs</strong>: O(log n) search/insert/delete (balanced), but O(n) worst-case if unbalanced.</li>
    <li data-start="487" data-end="568"><strong data-start="487" data-end="518">Red-Black Trees</strong>: Always balanced, ensuring O(log n) operations.</li>
</ul>
<p class="" data-start="45" data-end="193"><!-- /wp:paragraph --></p>
<!-- /wp:paragraph -->